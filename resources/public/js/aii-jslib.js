(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Generated by js_of_ocaml 3.6.0
(function(joo_global_object)
   {"use strict";
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return caml_utf16_of_utf8(this.c)
        }};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    var caml_global_data=[0];
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=joo_global_object,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = "_bigarray";
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function caml_convert_bytes_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_bytes_of_string(s){return s}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function caml_ml_bytes_length(s){return s.l}
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_ba_deserialize(reader,sz)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:caml_ba_deserialize,
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    var caml_oo_last_id=0;
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_jsstring_of_string(s){return s.toString()}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))
       this.content[name] = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       this.content[name] = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         this.content[name] = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           this.content[name] = new MlFakeFile(bytes)}
         else
          caml_raise_sys_error
           (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var
       a=new (joo_global_object.Uint8Array)(1),
       buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try
       {return this.fs.existsSync(this.nm(name))?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.readdir
    =
    function(name)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.rename
    =
    function(o,n)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"
             &&
             joo_global_object.process.platform
             !==
             "browser"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_create_file(name,content)
     {var root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      joo_global_object.caml_fs_tmp = [];
      return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === null)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_int64_mod(x,y){return x.mod(y)}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    function caml_js_from_bool(x){return ! ! x}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_js_to_bool(x){return + x}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    var caml_ml_channels=new Array();
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function caml_string_of_bytes(s){return s}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    var caml_named_values={};
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_string_of_jsstring(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_return_exn_constant(tag){return tag}
    function caml_named_value(nm){return caml_named_values[nm]}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4?f(a0,a1,a2,a3):caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    caml_fs_init();
    var
     Out_of_memory=[248,caml_string_of_jsbytes("Out_of_memory"),-1],
     Sys_error=[248,caml_string_of_jsbytes("Sys_error"),-2],
     Failure=[248,caml_string_of_jsbytes("Failure"),-3],
     Invalid_argument=[248,caml_string_of_jsbytes("Invalid_argument"),-4],
     End_of_file=[248,caml_string_of_jsbytes("End_of_file"),-5],
     Division_by_zero=[248,caml_string_of_jsbytes("Division_by_zero"),-6],
     Not_found=[248,caml_string_of_jsbytes("Not_found"),-7],
     Match_failure=[248,caml_string_of_jsbytes("Match_failure"),-8],
     Stack_overflow=[248,caml_string_of_jsbytes("Stack_overflow"),-9],
     Sys_blocked_io=[248,caml_string_of_jsbytes("Sys_blocked_io"),-10],
     Assert_failure=[248,caml_string_of_jsbytes("Assert_failure"),-11],
     Undefined_recursive_module=
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-12],
     param=
      [0,
       [11,caml_string_of_jsbytes("invalid box description "),[3,0,0]],
       caml_string_of_jsbytes("invalid box description %S")],
     opt=[0,103],
     dummy_string=caml_string_of_jsbytes(""),
     dummy_int64=caml_int64_create_lo_mi_hi(1,0,0),
     hexa1=
      caml_string_of_jsbytes
       ("0000000000000000111111111111111122222222222222223333333333333333444444444444444455555555555555556666666666666666777777777777777788888888888888889999999999999999aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbccccccccccccccccddddddddddddddddeeeeeeeeeeeeeeeeffffffffffffffff"),
     hexa2=
      caml_string_of_jsbytes
       ("0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"),
     partial=[4,0,[0,2,2],0,0],
     acc=caml_int64_create_lo_mi_hi(0,0,0),
     fmt=
      [0,
       [4,0,0,0,[12,45,[4,0,0,0,[11,caml_string_of_jsbytes(": "),[15,0]]]]],
       caml_string_of_jsbytes("%d-%d: %a")],
     pow=caml_int64_create_lo_mi_hi(10817536,59604,0),
     ps_count_in_min=caml_int64_create_lo_mi_hi(11517952,3576278,0),
     ps_count_in_hour=caml_int64_create_lo_mi_hi(3211264,13250129,12),
     ps_count_in_day=caml_int64_create_lo_mi_hi(9961472,16013212,306),
     fname=caml_string_of_jsbytes("templatefees"),
     bkind_expr_SAABook=caml_string_of_jsbytes("book"),
     bkind_expr_SAAStandalone=caml_string_of_jsbytes("standalone"),
     bkind_expr_SpellOfGenesis=caml_string_of_jsbytes("spellofgenesis"),
     bkind_expr_SpellToSpirit=caml_string_of_jsbytes("spelltospirit"),
     bkind_expr_InjectionFailed=caml_string_of_jsbytes("failed"),
     bkind_expr_InjectionSuccessful=caml_string_of_jsbytes("successful"),
     bkind_expr_InjectionProgressin=caml_string_of_jsbytes("progressing"),
     bkind_expr_InjectionInvalidTok=caml_string_of_jsbytes("invalid-token"),
     tezos_network_desc=
      [0,
       caml_string_of_jsbytes("carthagenet"),
       caml_string_of_jsbytes("NetXjD3HPJJjmcd")],
     book_charge_desc=[254,0.5,1.],
     book_status_desc=
      [0,
       caml_string_of_jsbytes("medium"),
       caml_string_of_jsbytes("carefully reviewed")],
     book_reference=
      [0,
       caml_string_of_jsbytes("source code"),
       caml_string_of_jsbytes("source code of the contract"),
       caml_string_of_jsbytes
        ("https://acme.example.com#this_is_a_sample_link")],
     provider_info=
      [0,
       caml_string_of_jsbytes("Acme Corporation"),
       caml_string_of_jsbytes
        ("A fictinoal corporation who supplies fictional smart contract templates, among other things"),
       caml_string_of_jsbytes("https://acme.example.com")],
     book_entity=
      [0,
       caml_string_of_jsbytes("(fake_bookhash)"),
       caml_string_of_jsbytes("(fake_tmplversion)"),
       [0,
        [0,
         caml_string_of_jsbytes("genesis"),
         caml_string_of_jsbytes("(fake_sahash)")],
        [0,
         [0,
          caml_string_of_jsbytes("fnc1"),
          caml_string_of_jsbytes("(fake_sahash2)")],
         0]],
       caml_string_of_jsbytes("(fake_bahash)"),
       caml_string_of_jsbytes("prvd_acme"),
       [0,
        caml_string_of_jsbytes("Book of Sample"),
        caml_string_of_jsbytes("Book of Sample is a sample book.")],
       [0,
        [0,
         [0,
          caml_string_of_jsbytes("param"),
          caml_string_of_jsbytes("param desc")],
         0],
        [0,[0,caml_string_of_jsbytes("some contract term english"),1],0],
        [0,[0,caml_string_of_jsbytes("a caveat"),1],0]]],
     partial$0=
      [0,
       caml_string_of_jsbytes
        ("No parameter of the contract could be amended after the origination of the contract. Nor could the `refund_address` of a contribution be amended."),
       1],
     availableNetworks=
      [0,
       [0,
        caml_string_of_jsbytes("mainnet"),
        caml_string_of_jsbytes("NetXdQprcVkpaWU")],
       [0,
        [0,
         caml_string_of_jsbytes("testnet"),
         caml_string_of_jsbytes("NetXjD3HPJJjmcd")],
        [0,
         [0,
          caml_string_of_jsbytes("carthagenet"),
          caml_string_of_jsbytes("NetXjD3HPJJjmcd")],
         0]]],
     advertized_books=
      [0,
       [0,
        caml_string_of_jsbytes("bk_proto0_funny"),
        caml_string_of_jsbytes("MOCK_bookhash_proto0_funny")],
       [0,
        [0,
         caml_string_of_jsbytes("bk_proto0_frozen"),
         caml_string_of_jsbytes("MOCK_bookhash_proto0_frozen")],
        [0,
         [0,
          caml_string_of_jsbytes("bk_proto0_crowdfunding"),
          caml_string_of_jsbytes("MOCK_bookhash_proto0_crowdfunding")],
         0]]],
     clerkUserInfo=
      [0,
       caml_string_of_jsbytes("Ichiro Sakai"),
       caml_string_of_jsbytes("i.sakai@example.org"),
       caml_string_of_jsbytes("tz1NQ5Fk7eJCe1zGmngv2GRnJK9G1nEnQahQ")],
     ophash=
      caml_string_of_jsbytes
       ("oo7g6EYYT9JsK5kMaJMVr72avE1RmWMuxXvcw9bBpZUVHt4VupZ"),
     known_tokens=
      caml_string_of_jsbytes
       ("dummytok, dummytok+successful, dummytok+timeout, dummytok+failed, dummytok+toofreq"),
     tz_offset_s=[0,0],
     injtoken=caml_string_of_jsbytes("dummytok"),
     shared=
      [0,
       caml_string_of_jsbytes("calculateAddressFromPublicKeyAsync"),
       caml_string_of_jsbytes("calculateAddressFromPublicKey")],
     fixed_network=
      [0,
       caml_string_of_jsbytes("testnet"),
       caml_string_of_jsbytes("NetXjD3HPJJjmcd")],
     entrypoint=caml_string_of_jsbytes("TSCAInternalInterface");
    caml_register_global
     (11,Undefined_recursive_module,"Undefined_recursive_module");
    caml_register_global(10,Assert_failure,"Assert_failure");
    caml_register_global(9,Sys_blocked_io,"Sys_blocked_io");
    caml_register_global(8,Stack_overflow,"Stack_overflow");
    caml_register_global(7,Match_failure,"Match_failure");
    caml_register_global(6,Not_found,"Not_found");
    caml_register_global(5,Division_by_zero,"Division_by_zero");
    caml_register_global(4,End_of_file,"End_of_file");
    caml_register_global(3,Invalid_argument,"Invalid_argument");
    caml_register_global(2,Failure,"Failure");
    caml_register_global(1,Sys_error,"Sys_error");
    caml_register_global(0,Out_of_memory,"Out_of_memory");
    var
     _c_=caml_string_of_jsbytes("output_substring"),
     _a_=caml_string_of_jsbytes("true"),
     _b_=caml_string_of_jsbytes("false"),
     _d_=caml_string_of_jsbytes("option is None"),
     _f_=caml_string_of_jsbytes("\\\\"),
     _g_=caml_string_of_jsbytes("\\'"),
     _h_=caml_string_of_jsbytes("\\b"),
     _i_=caml_string_of_jsbytes("\\t"),
     _j_=caml_string_of_jsbytes("\\n"),
     _k_=caml_string_of_jsbytes("\\r"),
     _e_=caml_string_of_jsbytes("Char.chr"),
     _n_=caml_string_of_jsbytes("String.blit / Bytes.blit_string"),
     _m_=caml_string_of_jsbytes("Bytes.blit"),
     _l_=caml_string_of_jsbytes("String.sub / Bytes.sub"),
     _o_=caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     _q_=caml_string_of_jsbytes("Array.blit"),
     _p_=caml_string_of_jsbytes("Array.init"),
     _v_=caml_string_of_jsbytes("Map.remove_min_elt"),
     _w_=[0,0,0,0],
     _x_=[0,caml_string_of_jsbytes("map.ml"),398,10],
     _y_=[0,0,0],
     _r_=caml_string_of_jsbytes("Map.bal"),
     _s_=caml_string_of_jsbytes("Map.bal"),
     _t_=caml_string_of_jsbytes("Map.bal"),
     _u_=caml_string_of_jsbytes("Map.bal"),
     _A_=caml_string_of_jsbytes("Stdlib.Queue.Empty"),
     _B_=caml_string_of_jsbytes("CamlinternalLazy.Undefined"),
     _G_=caml_string_of_jsbytes("Buffer.add_substring/add_subbytes"),
     _F_=caml_string_of_jsbytes("Buffer.add: cannot grow buffer"),
     _E_=[0,caml_string_of_jsbytes("buffer.ml"),93,2],
     _D_=[0,caml_string_of_jsbytes("buffer.ml"),94,2],
     _C_=caml_string_of_jsbytes("Buffer.sub"),
     _P_=caml_string_of_jsbytes("%c"),
     _Q_=caml_string_of_jsbytes("%s"),
     _R_=caml_string_of_jsbytes("%i"),
     _S_=caml_string_of_jsbytes("%li"),
     _T_=caml_string_of_jsbytes("%ni"),
     _U_=caml_string_of_jsbytes("%Li"),
     _V_=caml_string_of_jsbytes("%f"),
     _W_=caml_string_of_jsbytes("%B"),
     _X_=caml_string_of_jsbytes("%{"),
     _Y_=caml_string_of_jsbytes("%}"),
     _Z_=caml_string_of_jsbytes("%("),
     ___=caml_string_of_jsbytes("%)"),
     _$_=caml_string_of_jsbytes("%a"),
     _aa_=caml_string_of_jsbytes("%t"),
     _ab_=caml_string_of_jsbytes("%?"),
     _ac_=caml_string_of_jsbytes("%r"),
     _ad_=caml_string_of_jsbytes("%_r"),
     _ae_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),850,23],
     _ap_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),814,21],
     _ah_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),815,21],
     _aq_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),818,21],
     _ai_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),819,21],
     _ar_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),822,19],
     _aj_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),823,19],
     _as_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),826,22],
     _ak_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),827,22],
     _at_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),831,30],
     _al_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),832,30],
     _an_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),836,26],
     _af_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),837,26],
     _ao_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),846,28],
     _ag_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),847,28],
     _am_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),851,23],
     _bp_=caml_string_of_jsbytes("%u"),
     _bn_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1558,4],
     _bo_=caml_string_of_jsbytes("Printf: bad conversion %["),
     _bq_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1626,39],
     _br_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1649,31],
     _bs_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1650,31],
     _bt_=caml_string_of_jsbytes("Printf: bad conversion %_"),
     _bu_=caml_string_of_jsbytes("@{"),
     _bv_=caml_string_of_jsbytes("@["),
     _bw_=caml_string_of_jsbytes("@{"),
     _bx_=caml_string_of_jsbytes("@["),
     _by_=caml_string_of_jsbytes(""),
     _bz_=[0,0,4],
     _bA_=caml_string_of_jsbytes(""),
     _bB_=caml_string_of_jsbytes("b"),
     _bC_=caml_string_of_jsbytes("h"),
     _bD_=caml_string_of_jsbytes("hov"),
     _bE_=caml_string_of_jsbytes("hv"),
     _bF_=caml_string_of_jsbytes("v"),
     _bm_=caml_string_of_jsbytes("nan"),
     _bk_=caml_string_of_jsbytes("neg_infinity"),
     _bl_=caml_string_of_jsbytes("infinity"),
     _bj_=caml_string_of_jsbytes("."),
     _a9_=caml_string_of_jsbytes("%+nd"),
     _a__=caml_string_of_jsbytes("% nd"),
     _ba_=caml_string_of_jsbytes("%+ni"),
     _bb_=caml_string_of_jsbytes("% ni"),
     _bc_=caml_string_of_jsbytes("%nx"),
     _bd_=caml_string_of_jsbytes("%#nx"),
     _be_=caml_string_of_jsbytes("%nX"),
     _bf_=caml_string_of_jsbytes("%#nX"),
     _bg_=caml_string_of_jsbytes("%no"),
     _bh_=caml_string_of_jsbytes("%#no"),
     _a8_=caml_string_of_jsbytes("%nd"),
     _a$_=caml_string_of_jsbytes("%ni"),
     _bi_=caml_string_of_jsbytes("%nu"),
     _aW_=caml_string_of_jsbytes("%+ld"),
     _aX_=caml_string_of_jsbytes("% ld"),
     _aZ_=caml_string_of_jsbytes("%+li"),
     _a0_=caml_string_of_jsbytes("% li"),
     _a1_=caml_string_of_jsbytes("%lx"),
     _a2_=caml_string_of_jsbytes("%#lx"),
     _a3_=caml_string_of_jsbytes("%lX"),
     _a4_=caml_string_of_jsbytes("%#lX"),
     _a5_=caml_string_of_jsbytes("%lo"),
     _a6_=caml_string_of_jsbytes("%#lo"),
     _aV_=caml_string_of_jsbytes("%ld"),
     _aY_=caml_string_of_jsbytes("%li"),
     _a7_=caml_string_of_jsbytes("%lu"),
     _aJ_=caml_string_of_jsbytes("%+Ld"),
     _aK_=caml_string_of_jsbytes("% Ld"),
     _aM_=caml_string_of_jsbytes("%+Li"),
     _aN_=caml_string_of_jsbytes("% Li"),
     _aO_=caml_string_of_jsbytes("%Lx"),
     _aP_=caml_string_of_jsbytes("%#Lx"),
     _aQ_=caml_string_of_jsbytes("%LX"),
     _aR_=caml_string_of_jsbytes("%#LX"),
     _aS_=caml_string_of_jsbytes("%Lo"),
     _aT_=caml_string_of_jsbytes("%#Lo"),
     _aI_=caml_string_of_jsbytes("%Ld"),
     _aL_=caml_string_of_jsbytes("%Li"),
     _aU_=caml_string_of_jsbytes("%Lu"),
     _aw_=caml_string_of_jsbytes("%+d"),
     _ax_=caml_string_of_jsbytes("% d"),
     _az_=caml_string_of_jsbytes("%+i"),
     _aA_=caml_string_of_jsbytes("% i"),
     _aB_=caml_string_of_jsbytes("%x"),
     _aC_=caml_string_of_jsbytes("%#x"),
     _aD_=caml_string_of_jsbytes("%X"),
     _aE_=caml_string_of_jsbytes("%#X"),
     _aF_=caml_string_of_jsbytes("%o"),
     _aG_=caml_string_of_jsbytes("%#o"),
     _av_=caml_string_of_jsbytes("%d"),
     _ay_=caml_string_of_jsbytes("%i"),
     _aH_=caml_string_of_jsbytes("%u"),
     _H_=caml_string_of_jsbytes("@]"),
     _I_=caml_string_of_jsbytes("@}"),
     _J_=caml_string_of_jsbytes("@?"),
     _K_=caml_string_of_jsbytes("@\n"),
     _L_=caml_string_of_jsbytes("@."),
     _M_=caml_string_of_jsbytes("@@"),
     _N_=caml_string_of_jsbytes("@%"),
     _O_=caml_string_of_jsbytes("@"),
     _au_=caml_string_of_jsbytes("CamlinternalFormat.Type_mismatch"),
     _kk_=caml_string_of_jsbytes("OCAMLRUNPARAM"),
     _ki_=caml_string_of_jsbytes("CAMLRUNPARAM"),
     _bG_=caml_string_of_jsbytes(""),
     _b1_=[3,0,3],
     _b2_=caml_string_of_jsbytes("."),
     _bY_=caml_string_of_jsbytes(">"),
     _bZ_=caml_string_of_jsbytes("<\/"),
     _b0_=caml_string_of_jsbytes(""),
     _bV_=caml_string_of_jsbytes(">"),
     _bW_=caml_string_of_jsbytes("<"),
     _bX_=caml_string_of_jsbytes(""),
     _bU_=caml_string_of_jsbytes("\n"),
     _bQ_=caml_string_of_jsbytes(""),
     _bR_=caml_string_of_jsbytes(""),
     _bS_=caml_string_of_jsbytes(""),
     _bT_=caml_string_of_jsbytes(""),
     _bP_=[0,caml_string_of_jsbytes("")],
     _bL_=caml_string_of_jsbytes(""),
     _bM_=caml_string_of_jsbytes(""),
     _bN_=caml_string_of_jsbytes(""),
     _bO_=caml_string_of_jsbytes(""),
     _bK_=[0,caml_string_of_jsbytes(""),0,caml_string_of_jsbytes("")],
     _bJ_=caml_string_of_jsbytes(""),
     _bI_=caml_string_of_jsbytes("Stdlib.Format.String_tag"),
     _b3_=caml_string_of_jsbytes(""),
     _b4_=caml_string_of_jsbytes("Js_of_ocaml__Js.Error"),
     _b5_=caml_string_of_jsbytes("jsError"),
     _b6_=caml_string_of_jsbytes("Length of alphabet must be 64"),
     _b7_=caml_string_of_jsbytes("Alphabet can not contain padding character"),
     _b8_=
      caml_string_of_jsbytes
       ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),
     _b9_=
      caml_string_of_jsbytes
       ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),
     _cf_=
      [0,
       [17,[0,caml_string_of_jsbytes("@;"),1,0],0],
       caml_string_of_jsbytes("@;")],
     _ce_=[0,[12,32,0],caml_string_of_jsbytes(" ")],
     _cd_=[0,[11,caml_string_of_jsbytes("  "),0],caml_string_of_jsbytes("  ")],
     _cg_=[0,[15,[4,6,0,[0,2],[15,0]]],caml_string_of_jsbytes("%a%.2x%a")],
     _cc_=
      [0,
       [11,
        caml_string_of_jsbytes("Cstruct.blit_from_string src="),
        [15,
         [11,
          caml_string_of_jsbytes(" dst="),
          [15,
           [11,
            caml_string_of_jsbytes(" dst-off="),
            [4,0,0,0,[11,caml_string_of_jsbytes(" len="),[4,0,0,0,0]]]]]]]],
       caml_string_of_jsbytes
        ("Cstruct.blit_from_string src=%a dst=%a dst-off=%d len=%d")],
     _cb_=
      [0,
       [11,
        caml_string_of_jsbytes("Cstruct.blit_from_string src="),
        [15,
         [11,
          caml_string_of_jsbytes(" dst="),
          [15,
           [11,
            caml_string_of_jsbytes(" src-off="),
            [4,0,0,0,[11,caml_string_of_jsbytes(" len="),[4,0,0,0,0]]]]]]]],
       caml_string_of_jsbytes
        ("Cstruct.blit_from_string src=%a dst=%a src-off=%d len=%d")],
     _ca_=
      [0,
       [11,
        caml_string_of_jsbytes("Cstruct.set_len "),
        [15,[12,32,[4,0,0,0,0]]]],
       caml_string_of_jsbytes("Cstruct.set_len %a %d")],
     _b$_=[0,[12,91,[4,0,0,0,[12,93,0]]],caml_string_of_jsbytes("[%d]")],
     _b__=
      [0,
       [12,
        91,
        [4,
         0,
         0,
         0,
         [12,
          44,
          [4,0,0,0,[11,caml_string_of_jsbytes("]("),[4,0,0,0,[12,41,0]]]]]]],
       caml_string_of_jsbytes("[%d,%d](%d)")],
     _ch_=[0,[17,3,[15,[17,4,0]]],caml_string_of_jsbytes("@\n%a@.")],
     _ck_=
      [0,
       [11,caml_string_of_jsbytes("hex conversion: invalid hex string"),0],
       caml_string_of_jsbytes("hex conversion: invalid hex string")],
     _cj_=caml_string_of_jsbytes(""),
     _ci_=
      [0,
       [11,
        caml_string_of_jsbytes("Hex.to_char: "),
        [4,0,0,0,[11,caml_string_of_jsbytes(" is an invalid char"),0]]],
       caml_string_of_jsbytes("Hex.to_char: %d is an invalid char")],
     _cl_=caml_string_of_jsbytes(""),
     _cm_=caml_string_of_jsbytes("Jscodec.Records.Field_codec_mismatch"),
     _cR_=
      [0,
       [4,
        0,
        [0,2,4],
        0,
        [12,
         45,
         [4,
          0,
          [0,2,2],
          0,
          [12,
           45,
           [4,
            0,
            [0,2,2],
            0,
            [0,[4,0,[0,2,2],0,[12,58,[4,0,[0,2,2],0,[12,58,partial]]]]]]]]]],
       caml_string_of_jsbytes("%04d-%02d-%02d%c%02d:%02d:%02d")],
     _cS_=[0,[12,46,[7,0,[1,2],0,0]],caml_string_of_jsbytes(".%0*Ld")],
     _cU_=[0,[12,90,0],caml_string_of_jsbytes("Z")],
     _cT_=
      [0,
       [0,[4,0,[0,2,2],0,[12,58,[4,0,[0,2,2],0,0]]]],
       caml_string_of_jsbytes("%c%02d:%02d")],
     _cQ_=[0,0,1],
     _cP_=caml_int64_create_lo_mi_hi(0,0,0),
     _cO_=[0,0],
     _cL_=[0,0],
     _cN_=[0,122,0],
     _cM_=[0,43,[0,45,[0,90,0]]],
     _cK_=caml_int64_create_lo_mi_hi(10,0,0),
     _cJ_=[0,122,0],
     _cI_=[0,46,[0,43,[0,45,[0,90,0]]]],
     _cH_=[0,116,[0,32,0]],
     _cG_=[0,84,0],
     _cF_=caml_list_of_js_array([498443355,48,49,50,51,52,53,54,55,56,57]),
     _cC_=
      [0,
       [17,[0,caml_string_of_jsbytes("@ "),1,0],[1,0]],
       caml_string_of_jsbytes("@ %C")],
     _cA_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,
         caml_string_of_jsbytes("invalid"),
         [17,
          [0,caml_string_of_jsbytes("@ "),1,0],
          [11,
           caml_string_of_jsbytes("time"),
           [17,
            [0,caml_string_of_jsbytes("@ "),1,0],
            [11,caml_string_of_jsbytes("stamp"),[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[invalid@ time@ stamp@]")],
     _cB_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,
         caml_string_of_jsbytes("trailing"),
         [17,
          [0,caml_string_of_jsbytes("@ "),1,0],
          [11,caml_string_of_jsbytes("input"),[17,0,0]]]]],
       caml_string_of_jsbytes("@[trailing@ input@]")],
     _cz_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,
         caml_string_of_jsbytes("unexpected"),
         [17,
          [0,caml_string_of_jsbytes("@ "),1,0],
          [11,
           caml_string_of_jsbytes("end"),
           [17,
            [0,caml_string_of_jsbytes("@ "),1,0],
            [11,
             caml_string_of_jsbytes("of"),
             [17,
              [0,caml_string_of_jsbytes("@ "),1,0],
              [11,caml_string_of_jsbytes("input"),[17,0,0]]]]]]]]],
       caml_string_of_jsbytes("@[unexpected@ end@ of@ input@]")],
     _cD_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,
         caml_string_of_jsbytes("expected"),
         [17,
          [0,caml_string_of_jsbytes("@ "),1,0],
          [12,
           97,
           [17,
            [0,caml_string_of_jsbytes("@ "),1,0],
            [11,
             caml_string_of_jsbytes("character"),
             [17,
              [0,caml_string_of_jsbytes("@ "),1,0],
              [11,caml_string_of_jsbytes("in:"),[15,[17,0,0]]]]]]]]]],
       caml_string_of_jsbytes("@[expected@ a@ character@ in:%a@]")],
     _cw_=caml_int64_create_lo_mi_hi(0,0,0),
     _cu_=caml_int64_create_lo_mi_hi(0,0,0),
     _cv_=caml_int64_create_lo_mi_hi(0,0,0),
     _cx_=
      [0,
       caml_int64_create_lo_mi_hi(10817536,59604,0),
       caml_int64_create_lo_mi_hi(7792640,5960,0),
       caml_int64_create_lo_mi_hi(779264,596,0),
       caml_int64_create_lo_mi_hi(10144256,59,0),
       caml_int64_create_lo_mi_hi(16113920,5,0),
       caml_int64_create_lo_mi_hi(10000000,0,0),
       caml_int64_create_lo_mi_hi(1000000,0,0),
       caml_int64_create_lo_mi_hi(100000,0,0),
       caml_int64_create_lo_mi_hi(10000,0,0),
       caml_int64_create_lo_mi_hi(1000,0,0),
       caml_int64_create_lo_mi_hi(100,0,0),
       caml_int64_create_lo_mi_hi(10,0,0),
       caml_int64_create_lo_mi_hi(1,0,0)],
     _cy_=[0,31,28,31,30,31,30,31,31,30,31,30,31],
     _cE_=caml_string_of_jsbytes("Ptime.RFC3339"),
     _gU_=[0,caml_string_of_jsbytes("aii/types.ml"),179,2],
     _gS_=caml_string_of_jsbytes("reason"),
     _gT_=caml_string_of_jsbytes("status"),
     _gQ_=caml_string_of_jsbytes("status"),
     _gR_=caml_string_of_jsbytes("reason"),
     _gM_=caml_string_of_jsbytes("logs"),
     _gN_=caml_string_of_jsbytes("status"),
     _gK_=caml_string_of_jsbytes("status"),
     _gL_=caml_string_of_jsbytes("logs"),
     _gE_=caml_string_of_jsbytes("logs"),
     _gF_=caml_string_of_jsbytes("explorerlink"),
     _gG_=caml_string_of_jsbytes("ophash"),
     _gH_=caml_string_of_jsbytes("status"),
     _gA_=caml_string_of_jsbytes("status"),
     _gB_=caml_string_of_jsbytes("ophash"),
     _gC_=caml_string_of_jsbytes("explorerlink"),
     _gD_=caml_string_of_jsbytes("logs"),
     _gt_=caml_string_of_jsbytes("logs"),
     _gu_=caml_string_of_jsbytes("reason"),
     _gv_=caml_string_of_jsbytes("status"),
     _gq_=caml_string_of_jsbytes("status"),
     _gr_=caml_string_of_jsbytes("reason"),
     _gs_=caml_string_of_jsbytes("logs"),
     _gl_=caml_string_of_jsbytes("link"),
     _gm_=caml_string_of_jsbytes("label"),
     _gj_=caml_string_of_jsbytes("label"),
     _gk_=caml_string_of_jsbytes("link"),
     _gg_=[0,caml_string_of_jsbytes("aii/types.ml"),157,2],
     _ge_=caml_string_of_jsbytes("error"),
     _gf_=caml_string_of_jsbytes("succeeded"),
     _gc_=caml_string_of_jsbytes("succeeded"),
     _gd_=caml_string_of_jsbytes("error"),
     _f7_=caml_string_of_jsbytes("adjustedtxn"),
     _f8_=caml_string_of_jsbytes("rawamount"),
     _f9_=caml_string_of_jsbytes("templatefees"),
     _f__=caml_string_of_jsbytes("networkfees"),
     _f$_=caml_string_of_jsbytes("succeeded"),
     _f3_=caml_string_of_jsbytes("succeeded"),
     _f4_=caml_string_of_jsbytes("networkfees"),
     _f5_=caml_string_of_jsbytes("rawamount"),
     _f6_=caml_string_of_jsbytes("adjustedtxn"),
     _fW_=caml_string_of_jsbytes("burn"),
     _fX_=caml_string_of_jsbytes("fee"),
     _fU_=caml_string_of_jsbytes("fee"),
     _fV_=caml_string_of_jsbytes("burn"),
     _fQ_=caml_string_of_jsbytes("provider"),
     _fR_=caml_string_of_jsbytes("agency"),
     _fO_=caml_string_of_jsbytes("agency"),
     _fP_=caml_string_of_jsbytes("provider"),
     _fJ_=caml_string_of_jsbytes("target"),
     _fK_=caml_string_of_jsbytes("spell"),
     _fL_=caml_string_of_jsbytes("network"),
     _fG_=caml_string_of_jsbytes("network"),
     _fH_=caml_string_of_jsbytes("spell"),
     _fI_=caml_string_of_jsbytes("target"),
     _fC_=[0,caml_string_of_jsbytes("aii/types.ml"),141,2],
     _fz_=caml_string_of_jsbytes("sprthash"),
     _fA_=caml_string_of_jsbytes("tmplversion"),
     _fB_=caml_string_of_jsbytes("spellkind"),
     _fw_=caml_string_of_jsbytes("spellkind"),
     _fx_=caml_string_of_jsbytes("tmplversion"),
     _fy_=caml_string_of_jsbytes("sprthash"),
     _fr_=caml_string_of_jsbytes("tmplversion"),
     _fs_=caml_string_of_jsbytes("spellkind"),
     _fp_=caml_string_of_jsbytes("spellkind"),
     _fq_=caml_string_of_jsbytes("tmplversion"),
     _fk_=caml_string_of_jsbytes("srcaddr"),
     _fl_=caml_string_of_jsbytes("email"),
     _fm_=caml_string_of_jsbytes("name"),
     _fh_=caml_string_of_jsbytes("name"),
     _fi_=caml_string_of_jsbytes("email"),
     _fj_=caml_string_of_jsbytes("srcaddr"),
     _fd_=[0,caml_string_of_jsbytes("aii/types.ml"),129,0],
     _fb_=caml_string_of_jsbytes("error"),
     _fc_=caml_string_of_jsbytes("valid"),
     _e$_=caml_string_of_jsbytes("valid"),
     _fa_=caml_string_of_jsbytes("error"),
     _e7_=caml_string_of_jsbytes("explanation"),
     _e8_=caml_string_of_jsbytes("valid"),
     _e5_=caml_string_of_jsbytes("valid"),
     _e6_=caml_string_of_jsbytes("explanation"),
     _e1_=caml_string_of_jsbytes("bookhash"),
     _e2_=caml_string_of_jsbytes("bookident"),
     _eZ_=caml_string_of_jsbytes("bookident"),
     _e0_=caml_string_of_jsbytes("bookhash"),
     _eJ_=caml_string_of_jsbytes("contents"),
     _eK_=caml_string_of_jsbytes("language"),
     _eH_=caml_string_of_jsbytes("language"),
     _eI_=caml_string_of_jsbytes("contents"),
     _eE_=[0,caml_string_of_jsbytes("aii/types.ml"),93,0],
     _eA_=caml_string_of_jsbytes("website"),
     _eB_=caml_string_of_jsbytes("synopsis"),
     _eC_=caml_string_of_jsbytes("provider"),
     _eD_=caml_string_of_jsbytes("attachmentkind"),
     _ew_=caml_string_of_jsbytes("attachmentkind"),
     _ex_=caml_string_of_jsbytes("provider"),
     _ey_=caml_string_of_jsbytes("synopsis"),
     _ez_=caml_string_of_jsbytes("website"),
     _eq_=caml_string_of_jsbytes("bookhash"),
     _er_=caml_string_of_jsbytes("attachmentkind"),
     _eo_=caml_string_of_jsbytes("attachmentkind"),
     _ep_=caml_string_of_jsbytes("bookhash"),
     _ej_=caml_string_of_jsbytes("_queryinterp_endpoint"),
     _ek_=caml_string_of_jsbytes("_spellinterp_endpoint"),
     _el_=caml_string_of_jsbytes("ccgen"),
     _eg_=caml_string_of_jsbytes("ccgen"),
     _eh_=caml_string_of_jsbytes("_spellinterp_endpoint"),
     _ei_=caml_string_of_jsbytes("_queryinterp_endpoint"),
     _d8_=caml_string_of_jsbytes("detailedinfo"),
     _d9_=caml_string_of_jsbytes("basicinfo"),
     _d__=caml_string_of_jsbytes("provider"),
     _d$_=caml_string_of_jsbytes("bookapp"),
     _ea_=caml_string_of_jsbytes("spellAssistants"),
     _eb_=caml_string_of_jsbytes("tmplversion"),
     _ec_=caml_string_of_jsbytes("bookhash"),
     _d1_=caml_string_of_jsbytes("bookhash"),
     _d2_=caml_string_of_jsbytes("tmplversion"),
     _d3_=caml_string_of_jsbytes("spellAssistants"),
     _d4_=caml_string_of_jsbytes("bookapp"),
     _d5_=caml_string_of_jsbytes("provider"),
     _d6_=caml_string_of_jsbytes("basicinfo"),
     _d7_=caml_string_of_jsbytes("detailedinfo"),
     _dR_=caml_string_of_jsbytes("caveats"),
     _dS_=caml_string_of_jsbytes("englishterms"),
     _dT_=caml_string_of_jsbytes("parameters"),
     _dO_=caml_string_of_jsbytes("parameters"),
     _dP_=caml_string_of_jsbytes("englishterms"),
     _dQ_=caml_string_of_jsbytes("caveats"),
     _dJ_=caml_string_of_jsbytes("desc"),
     _dK_=caml_string_of_jsbytes("ident"),
     _dH_=caml_string_of_jsbytes("ident"),
     _dI_=caml_string_of_jsbytes("desc"),
     _dD_=caml_string_of_jsbytes("mandatory_consensus"),
     _dE_=caml_string_of_jsbytes("contents"),
     _dB_=caml_string_of_jsbytes("contents"),
     _dC_=caml_string_of_jsbytes("mandatory_consensus"),
     _dx_=caml_string_of_jsbytes("synopsis"),
     _dy_=caml_string_of_jsbytes("title"),
     _dv_=caml_string_of_jsbytes("title"),
     _dw_=caml_string_of_jsbytes("synopsis"),
     _dq_=caml_string_of_jsbytes("website"),
     _dr_=caml_string_of_jsbytes("intro"),
     _ds_=caml_string_of_jsbytes("displayname"),
     _dn_=caml_string_of_jsbytes("displayname"),
     _do_=caml_string_of_jsbytes("intro"),
     _dp_=caml_string_of_jsbytes("website"),
     _dh_=caml_string_of_jsbytes("link"),
     _di_=caml_string_of_jsbytes("synopsis"),
     _dj_=caml_string_of_jsbytes("title"),
     _de_=caml_string_of_jsbytes("title"),
     _df_=caml_string_of_jsbytes("synopsis"),
     _dg_=caml_string_of_jsbytes("link"),
     _c$_=caml_string_of_jsbytes("certification_status"),
     _da_=caml_string_of_jsbytes("contract_complexity"),
     _c9_=caml_string_of_jsbytes("contract_complexity"),
     _c__=caml_string_of_jsbytes("certification_status"),
     _c5_=caml_string_of_jsbytes("provider"),
     _c6_=caml_string_of_jsbytes("agency"),
     _c3_=caml_string_of_jsbytes("agency"),
     _c4_=caml_string_of_jsbytes("provider"),
     _cZ_=caml_string_of_jsbytes("chainid"),
     _c0_=caml_string_of_jsbytes("netident"),
     _cX_=caml_string_of_jsbytes("netident"),
     _cY_=caml_string_of_jsbytes("chainid"),
     _cV_=caml_string_of_jsbytes("chainid"),
     _cW_=caml_string_of_jsbytes("netident"),
     _c1_=caml_string_of_jsbytes("provider"),
     _c2_=caml_string_of_jsbytes("agency"),
     _c7_=caml_string_of_jsbytes("certification_status"),
     _c8_=caml_string_of_jsbytes("contract_complexity"),
     _db_=caml_string_of_jsbytes("link"),
     _dc_=caml_string_of_jsbytes("synopsis"),
     _dd_=caml_string_of_jsbytes("title"),
     _dk_=caml_string_of_jsbytes("website"),
     _dl_=caml_string_of_jsbytes("intro"),
     _dm_=caml_string_of_jsbytes("displayname"),
     _dt_=caml_string_of_jsbytes("synopsis"),
     _du_=caml_string_of_jsbytes("title"),
     _dz_=caml_string_of_jsbytes("mandatory_consensus"),
     _dA_=caml_string_of_jsbytes("contents"),
     _dF_=caml_string_of_jsbytes("desc"),
     _dG_=caml_string_of_jsbytes("ident"),
     _dL_=caml_string_of_jsbytes("caveats"),
     _dM_=caml_string_of_jsbytes("englishterms"),
     _dN_=caml_string_of_jsbytes("parameters"),
     _dU_=caml_string_of_jsbytes("detailedinfo"),
     _dV_=caml_string_of_jsbytes("basicinfo"),
     _dW_=caml_string_of_jsbytes("provider"),
     _dX_=caml_string_of_jsbytes("bookapp"),
     _dY_=caml_string_of_jsbytes("spellAssistants"),
     _dZ_=caml_string_of_jsbytes("tmplversion"),
     _d0_=caml_string_of_jsbytes("bookhash"),
     _ed_=caml_string_of_jsbytes("_queryinterp_endpoint"),
     _ee_=caml_string_of_jsbytes("_spellinterp_endpoint"),
     _ef_=caml_string_of_jsbytes("ccgen"),
     _em_=caml_string_of_jsbytes("bookhash"),
     _en_=caml_string_of_jsbytes("attachmentkind"),
     _es_=caml_string_of_jsbytes("website"),
     _et_=caml_string_of_jsbytes("synopsis"),
     _eu_=caml_string_of_jsbytes("provider"),
     _ev_=caml_string_of_jsbytes("attachmentkind"),
     _eF_=caml_string_of_jsbytes("contents"),
     _eG_=caml_string_of_jsbytes("language"),
     _eL_=caml_string_of_jsbytes("code"),
     _eM_=caml_string_of_jsbytes("attachment"),
     _eN_=caml_string_of_jsbytes("op"),
     _eO_=caml_string_of_jsbytes("spellkind"),
     _eP_=caml_string_of_jsbytes("targetingbroker"),
     _eQ_=caml_string_of_jsbytes("spell"),
     _eR_=caml_string_of_jsbytes("tmplversion"),
     _eS_=caml_string_of_jsbytes("spellkind"),
     _eT_=caml_string_of_jsbytes("spell"),
     _eU_=caml_string_of_jsbytes("sprthash"),
     _eV_=caml_string_of_jsbytes("tmplversion"),
     _eW_=caml_string_of_jsbytes("spellkind"),
     _eX_=caml_string_of_jsbytes("bookhash"),
     _eY_=caml_string_of_jsbytes("bookident"),
     _e3_=caml_string_of_jsbytes("explanation"),
     _e4_=caml_string_of_jsbytes("valid"),
     _e9_=caml_string_of_jsbytes("error"),
     _e__=caml_string_of_jsbytes("valid"),
     _fe_=caml_string_of_jsbytes("srcaddr"),
     _ff_=caml_string_of_jsbytes("email"),
     _fg_=caml_string_of_jsbytes("name"),
     _fn_=caml_string_of_jsbytes("tmplversion"),
     _fo_=caml_string_of_jsbytes("spellkind"),
     _ft_=caml_string_of_jsbytes("sprthash"),
     _fu_=caml_string_of_jsbytes("tmplversion"),
     _fv_=caml_string_of_jsbytes("spellkind"),
     _fD_=caml_string_of_jsbytes("target"),
     _fE_=caml_string_of_jsbytes("spell"),
     _fF_=caml_string_of_jsbytes("network"),
     _fM_=caml_string_of_jsbytes("provider"),
     _fN_=caml_string_of_jsbytes("agency"),
     _fS_=caml_string_of_jsbytes("burn"),
     _fT_=caml_string_of_jsbytes("fee"),
     _fY_=caml_string_of_jsbytes("adjustedtxn"),
     _fZ_=caml_string_of_jsbytes("rawamount"),
     _f0_=caml_string_of_jsbytes("templatefees"),
     _f1_=caml_string_of_jsbytes("networkfees"),
     _f2_=caml_string_of_jsbytes("succeeded"),
     _ga_=caml_string_of_jsbytes("error"),
     _gb_=caml_string_of_jsbytes("succeeded"),
     _gh_=caml_string_of_jsbytes("link"),
     _gi_=caml_string_of_jsbytes("label"),
     _gn_=caml_string_of_jsbytes("logs"),
     _go_=caml_string_of_jsbytes("reason"),
     _gp_=caml_string_of_jsbytes("status"),
     _gw_=caml_string_of_jsbytes("logs"),
     _gx_=caml_string_of_jsbytes("explorerlink"),
     _gy_=caml_string_of_jsbytes("ophash"),
     _gz_=caml_string_of_jsbytes("status"),
     _gI_=caml_string_of_jsbytes("logs"),
     _gJ_=caml_string_of_jsbytes("status"),
     _gO_=caml_string_of_jsbytes("reason"),
     _gP_=caml_string_of_jsbytes("status"),
     _gV_=
      caml_string_of_jsbytes
       ("https://tsca.example.org/fake_queryinterp_endpoint"),
     _gW_=
      caml_string_of_jsbytes
       ("https://tsca.example.org/fake_spellinterp_endpoint"),
     _gX_=caml_string_of_jsbytes("(fake ccgen byteseq)"),
     _hI_=caml_string_of_jsbytes("explanation for "),
     _hF_=caml_string_of_jsbytes("invalid unfrozen format: "),
     _hG_=caml_string_of_jsbytes("fund_amount must be positive"),
     _hH_=caml_string_of_jsbytes("there must be one or more fund_owners"),
     _hE_=caml_string_of_jsbytes("explanation for "),
     _hD_=caml_string_of_jsbytes("amount must be positive"),
     _hB_=caml_string_of_jsbytes("MOCK_sahash_proto0_frozen_genesis"),
     _hC_=caml_string_of_jsbytes("MOCK_sahash_proto0_frozen_withdraw"),
     _hz_=caml_string_of_jsbytes("beneficiary"),
     _hA_=caml_string_of_jsbytes("amount"),
     _hx_=caml_string_of_jsbytes("amount"),
     _hy_=caml_string_of_jsbytes("beneficiary"),
     _hs_=caml_string_of_jsbytes("unfrozen"),
     _ht_=caml_string_of_jsbytes("fund_amount"),
     _hu_=caml_string_of_jsbytes("fund_owners"),
     _hp_=caml_string_of_jsbytes("fund_owners"),
     _hq_=caml_string_of_jsbytes("fund_amount"),
     _hr_=caml_string_of_jsbytes("unfrozen"),
     _hg_=caml_string_of_jsbytes("MOCK_bookhash_proto0_crowdfunding"),
     _hh_=caml_string_of_jsbytes("MOCK_bookhash_proto0_frozen"),
     _hi_=caml_string_of_jsbytes("MOCK_bookhash_proto0_funny"),
     _hj_=
      [0,
       caml_string_of_jsbytes("Very low"),
       caml_string_of_jsbytes("Carefully reviewed")],
     _hk_=
      [0,
       caml_string_of_jsbytes("Low"),
       caml_string_of_jsbytes("Formally certified")],
     _hl_=
      [0,
       caml_string_of_jsbytes("Medium"),
       caml_string_of_jsbytes("Formally certified")],
     _ha_=caml_string_of_jsbytes("MOCK_bookhash_proto0_crowdfunding"),
     _hb_=caml_string_of_jsbytes("MOCK_bookhash_proto0_frozen"),
     _hc_=caml_string_of_jsbytes("MOCK_bookhash_proto0_funny"),
     _hd_=[254,0.5,0.5],
     _he_=[254,0.5,1.5],
     _hf_=[254,0.5,4.5],
     _g__=caml_string_of_jsbytes("prvd_proto0_tsca"),
     _g$_=
      [0,
       caml_string_of_jsbytes("The TSCA Team"),
       caml_string_of_jsbytes
        ("The TSCA--Typical Smart Contract Agency--Team, who build this service"),
       caml_string_of_jsbytes("https://tsca.example.org")],
     _g4_=caml_string_of_jsbytes("MOCK_bookhash_proto0_crowdfunding"),
     _g5_=caml_string_of_jsbytes("MOCK_bookhash_proto0_frozen"),
     _g6_=caml_string_of_jsbytes("MOCK_bookhash_proto0_funny"),
     _g7_=
      [0,
       [0,
        caml_string_of_jsbytes("SCaml Source Code"),
        caml_string_of_jsbytes("Behavioral reference implementation in SCaml"),
        caml_string_of_jsbytes
         ("https://example.org#MOCK_bookhash_proto0_funny-ref-SCaml+Source+Code")],
       [0,
        [0,
         caml_string_of_jsbytes("Michelson Source Code"),
         caml_string_of_jsbytes("Effective contract code in Michelson"),
         caml_string_of_jsbytes
          ("https://example.org#MOCK_bookhash_proto0_funny-ref-Michelson+Source+Code")],
        0]],
     _g8_=
      [0,
       [0,
        caml_string_of_jsbytes("SCaml Reference Implementation"),
        caml_string_of_jsbytes("Behavioral reference implementation in SCaml"),
        caml_string_of_jsbytes
         ("https://example.org#MOCK_bookhash_proto0_frozen-ref-SCaml+Reference+Implementation")],
       [0,
        [0,
         caml_string_of_jsbytes("Technical Notes"),
         caml_string_of_jsbytes("Technical Notes"),
         caml_string_of_jsbytes
          ("https://example.org#MOCK_bookhash_proto0_frozen-ref-Certified+Technical+Notes")],
        [0,
         [0,
          caml_string_of_jsbytes("Certified Source Code"),
          caml_string_of_jsbytes
           ("Source code and mechanized verification script in Coq"),
          caml_string_of_jsbytes
           ("https://example.org#MOCK_bookhash_proto0_frozen-ref-Certified+Source+Code")],
         0]]],
     _g9_=
      [0,
       [0,
        caml_string_of_jsbytes("SCaml Reference Implementation"),
        caml_string_of_jsbytes("Behavioral reference implementation in SCaml"),
        caml_string_of_jsbytes
         ("https://example.org#MOCK_bookhash_proto0_crowdfunding-ref-SCaml+Reference+Implementation")],
       [0,
        [0,
         caml_string_of_jsbytes("Technical Notes"),
         caml_string_of_jsbytes("Technical Notes"),
         caml_string_of_jsbytes
          ("https://example.org#MOCK_bookhash_proto0_crowdfunding-ref-Certified+Technical+Notes")],
        [0,
         [0,
          caml_string_of_jsbytes("Certified Source Code"),
          caml_string_of_jsbytes
           ("Source code and mechanized verification script in Coq"),
          caml_string_of_jsbytes
           ("https://example.org#MOCK_bookhash_proto0_crowdfunding-ref-Certified+Source+Code")],
         0]]],
     _gY_=caml_string_of_jsbytes("MOCK_bookhash_proto0_crowdfunding"),
     _gZ_=caml_string_of_jsbytes("MOCK_bookhash_proto0_frozen"),
     _g0_=caml_string_of_jsbytes("MOCK_bookhash_proto0_funny"),
     _g1_=
      [0,
       caml_string_of_jsbytes("MOCK_bookhash_proto0_funny"),
       caml_string_of_jsbytes("MOCK_tmplversion_proto0_funny"),
       [0,
        [0,
         caml_string_of_jsbytes("genesis"),
         caml_string_of_jsbytes("MOCK_sahash_proto0_funny_genesis")],
        [0,
         [0,
          caml_string_of_jsbytes("iamfunny"),
          caml_string_of_jsbytes("MOCK_sahash_proto0_funny_iamfunny")],
         0]],
       caml_string_of_jsbytes("MOCK_bahash_proto0_funny0"),
       caml_string_of_jsbytes("prvd_proto0_tsca"),
       [0,
        caml_string_of_jsbytes("Book of Funny"),
        caml_string_of_jsbytes
         ("Book of Funny is a demo-purpose contract template that creates a contract that sends back to the invoker half of its current balance every time it is invoked. It could be invoked by anyone so basically the originator is likely to be losing tokens. Do not use this template on networks with real tokens.")],
       [0,
        [0,
         [0,
          caml_string_of_jsbytes("initial_balance"),
          caml_string_of_jsbytes
           ("the initial balance of the contract to be originated")],
         0],
        [0,
         [0,
          caml_string_of_jsbytes
           ("Any implicit account could submit a transaction to the blockchain which results in an invocation to the originated contract. When such an invocation being successful, the originated contract will transfer half of its current balance back to the implicit account who submitted the transaction."),
          1],
         0],
        [0,
         [0,
          caml_string_of_jsbytes
           ("DO NOT USE ON THE MAINNET: contracts originated from this template gives away its initial balance to anyone who requests, and is created solely for the purpose of demonstration. Therefore it is strongly advised against using this template on chains that doesn\xe2\x80\x99t not have free tokens otherwise, especially the Tezos Mainnet."),
          1],
         0]]],
     _g2_=
      [0,
       caml_string_of_jsbytes("MOCK_bookhash_proto0_frozen"),
       caml_string_of_jsbytes("MOCK_tmplversion_proto0_frozen"),
       [0,
        [0,
         caml_string_of_jsbytes("genesis"),
         caml_string_of_jsbytes("MOCK_sahash_proto0_frozen_genesis")],
        [0,
         [0,
          caml_string_of_jsbytes("withdraw"),
          caml_string_of_jsbytes("MOCK_sahash_proto0_frozen_withdraw")],
         0]],
       caml_string_of_jsbytes("MOCK_bahash_proto0_frozen0"),
       caml_string_of_jsbytes("prvd_proto0_tsca"),
       [0,
        caml_string_of_jsbytes("Book of Frozen"),
        caml_string_of_jsbytes
         ('Book of Frozen creates a contract that freeze its initial balance until a configurable "unfrozen timestamp"')],
       [0,
        [0,
         [0,
          caml_string_of_jsbytes("fund_amount"),
          caml_string_of_jsbytes
           ("the initial balance of the contract to be frozen")],
         [0,
          [0,
           caml_string_of_jsbytes("unfrozen_timestamp"),
           caml_string_of_jsbytes
            ("the timestamp from which the frozen fund is released")],
          [0,
           [0,
            caml_string_of_jsbytes("fund_owners"),
            caml_string_of_jsbytes
             ("the owners of the fund, each of which could request a withdraw of the fund after `unfrozen_timestamp`. Each entry must be an implicit account address.")],
           0]]],
        [0,
         [0,
          caml_string_of_jsbytes
           ("The `fund_amount` will be held frozen in the originated contract until the `unfrozen_timestamp`, before which it is impossible to withdraw fund from the contract and after which any account listed in `fund_owners` could request a withdraw."),
          1],
         [0,
          [0,
           caml_string_of_jsbytes
            ("No parameter of the contract could be amended after the origination of the contract."),
           1],
          0]],
        [0,
         [0,
          caml_string_of_jsbytes
           ("There is absolutely no way to withdraw the frozen fund before `unfrozen_timestamp`. Think carefully before the origination."),
          1],
         [0,
          [0,
           caml_string_of_jsbytes
            ("DO NOT list smart contracts in the `fund_owners`: only implicit account could successfully request a withdraw."),
           1],
          [0,
           [0,
            caml_string_of_jsbytes
             ("Only accounts listed in the `fund_owners` could request withdraws from the fund after unfrozen. Be careful that you maintain control over at least one of those addresses after the unfrozen date."),
            1],
           0]]]]],
     _g3_=
      [0,
       caml_string_of_jsbytes("MOCK_bookhash_proto0_crowdfunding"),
       caml_string_of_jsbytes("MOCK_tmplversion_proto0_crowdfunding"),
       [0,
        [0,
         caml_string_of_jsbytes("genesis"),
         caml_string_of_jsbytes("MOCK_sahash_proto0_crowdfunding_genesis")],
        0],
       caml_string_of_jsbytes("MOCK_bahash_proto0_crowdfunding0"),
       caml_string_of_jsbytes("prvd_proto0_tsca"),
       [0,
        caml_string_of_jsbytes("Book of Crowdfunding"),
        caml_string_of_jsbytes
         ("Book of Crowdfunding creates a contract that accepts fundings from the crowd over a defined period of time. Optional funding target, maximum raise, and minimal contribution could be set.")],
       [0,
        [0,
         [0,
          caml_string_of_jsbytes("raisers"),
          caml_string_of_jsbytes
           ("the raisers of the crowdfunding, who could access the fund after a successful funding. Each entry must be an implicit account address.")],
         [0,
          [0,
           caml_string_of_jsbytes("funding_start"),
           caml_string_of_jsbytes
            ("the start of the funding period, must be within 3 months of the origination")],
          [0,
           [0,
            caml_string_of_jsbytes("funding_end"),
            caml_string_of_jsbytes
             ("the end of the funding period, must be within 9 months after the `funding_start`")],
           [0,
            [0,
             caml_string_of_jsbytes("unconditional_refund_start"),
             caml_string_of_jsbytes
              ("after which any raised fund will not be accessible to the raisers and funders could request a refund of their contributions, must be within 3 months after the `funding_end`")],
            [0,
             [0,
              caml_string_of_jsbytes("funding_target"),
              caml_string_of_jsbytes
               ("[optional] if provided, a funding attempt that raises less than this amount will be considered unsuccessful")],
             [0,
              [0,
               caml_string_of_jsbytes("maximum_raise"),
               caml_string_of_jsbytes
                ("[optional] if provided, a funding attempt could not raise more than this amount, must be above `funding_target` if that is also provided.")],
              [0,
               [0,
                caml_string_of_jsbytes("minimal_contribution"),
                caml_string_of_jsbytes
                 ("[optional] if provided, each contribution must be at least this amount")],
               0]]]]]]],
        [0,
         [0,
          caml_string_of_jsbytes
           ("A nominal fee of 1 tz will be buried (i.e. made unaccessible by anyone) upon origination."),
          1],
         [0,
          [0,
           caml_string_of_jsbytes
            ("Funders could make contributions within the funding period starting from `funding_start` and ending at `funding_end`. If `minimal_contribution` is set, each contribution must be at least that amount."),
           1],
          [0,
           [0,
            caml_string_of_jsbytes
             ("When making a contribution, the funder must provide a valid `refund_address`. Each `refund_address` must be an implicit account."),
            1],
           [0,
            [0,
             caml_string_of_jsbytes
              ("If `maximum_raise` is set, the contract cannot raise more than that amount. Contributions attempted after the amount is met will be rejected."),
             1],
            [0,
             [0,
              caml_string_of_jsbytes
               ("A raising attempt is considered successful when all of the following conditions are met\n  - funding_end` has been passed.\n  - If `funding_target` is set, the total contribution is no less than that amount."),
              1],
             [0,
              [0,
               caml_string_of_jsbytes
                ("A raising attempt is considered unsuccessful when all the following conditions are met\n  - `funding_end` has been passed.\n  - The raising attempt is not considered successful by the previous article"),
               1],
              [0,
               [0,
                caml_string_of_jsbytes
                 ("If the raising attempt were successful, anyone in the `raisers` could request a transfer of the raised fund before the `unconditional_refund_start`. Only one such transfer could be requested and the transfer will be made in whole."),
                1],
               [0,
                [0,
                 caml_string_of_jsbytes
                  ("If the raising attempt were unsuccessful, or no raisers\xe2\x80\x99 transfer were requested and the `unconditional_fund_start` had been passed, each funder could request a refund of their contribution from his/her `refund_address`. Each such refund will be made once in whole."),
                 1],
                [0,partial$0,0]]]]]]]]],
        [0,
         [0,
          caml_string_of_jsbytes
           ("Once originated, there is no way a crowdfunding could be stopped or cancelled."),
          1],
         [0,
          [0,
           caml_string_of_jsbytes
            ("A nominal fee of 1 tz will be unconditionally buried per origination. This is to prevent frauds."),
           1],
          [0,
           [0,
            caml_string_of_jsbytes
             ("Once a contribution is made, the contribution cannot be withdrawn. (Refund will be available if the funding attempt ends unsuccessfully or the successfully raised fund is not accessed by the raisers before `unconditional_refund_start`)"),
            1],
           [0,
            [0,
             caml_string_of_jsbytes
              ("It is the responsibility of each funder to ensure that the `refund_address` provided with a contribution remains valid when a refund is needed."),
             1],
            [0,
             [0,
              caml_string_of_jsbytes
               ("Access to the successfully raised fund, or the refund cannot be made in parts, i.e. such transactions will be made in whole amounts at once."),
              1],
             0]]]]]]],
     _hm_=caml_string_of_jsbytes("unfrozen"),
     _hn_=caml_string_of_jsbytes("fund_amount"),
     _ho_=caml_string_of_jsbytes("fund_owners"),
     _hv_=caml_string_of_jsbytes("beneficiary"),
     _hw_=caml_string_of_jsbytes("amount"),
     _hJ_=
      [0,
       3603131,
       caml_string_of_jsbytes
        ("03ef3ccca0cf0a4c1706cdd89d30f3ac3cef34fc78c23f140231c969501bc387d16c001e44b16562327dd33068e4731764191461bcccbe830af2ef25c35000a08d0600000d3c0b644fdf9081e80f73dd3a4735c5632c81da00")],
     _j5_=caml_string_of_jsbytes("/proto0/ledgerutils-pk-to-pkh"),
     _j6_=caml_string_of_jsbytes("pk.hex"),
     _j3_=caml_string_of_jsbytes(""),
     _jX_=
      caml_string_of_jsbytes
       ("typeof(aii_endpoint_passin)==='undefined'?null:aii_endpoint_passin"),
     _jY_=caml_string_of_jsbytes("https://devapi.tsca.kxc.io"),
     _jZ_=caml_string_of_jsbytes("aii/aii_jslib.ml"),
     _j0_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(": aii_endpoint='"),[2,0,[12,39,0]]]],
       caml_string_of_jsbytes("%s: aii_endpoint='%s'")],
     _jT_=
      caml_string_of_jsbytes
       ("typeof(aii_token_passin)==='undefined'?null:aii_token_passin"),
     _jU_=caml_string_of_jsbytes("notoken"),
     _jV_=caml_string_of_jsbytes("aii/aii_jslib.ml"),
     _jW_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(": aii_token='"),[2,0,[12,39,0]]]],
       caml_string_of_jsbytes("%s: aii_token='%s'")],
     _jQ_=caml_string_of_jsbytes(""),
     _jR_=caml_string_of_jsbytes("getBook"),
     _jN_=caml_string_of_jsbytes("bookhash"),
     _jM_=caml_string_of_jsbytes("bookhash"),
     _jE_=caml_string_of_jsbytes(""),
     _jn_=caml_string_of_jsbytes(" to obtain other behaviors"),
     _jo_=caml_string_of_jsbytes("use "),
     _jp_=caml_string_of_jsbytes("dummytok"),
     _jq_=caml_string_of_jsbytes("dummytok+successful"),
     _jr_=caml_string_of_jsbytes("dummytok+timeout"),
     _js_=caml_string_of_jsbytes("dummytok+toofreq"),
     _ju_=[3,caml_string_of_jsbytes("request too frequent")],
     _jv_=[3,caml_string_of_jsbytes("injtoken timeout")],
     _jw_=caml_string_of_jsbytes("injection successful: "),
     _jx_=caml_string_of_jsbytes("https://carthage.tzkt.io/"),
     _jy_=caml_string_of_jsbytes("Better Call Dev"),
     _jz_=caml_string_of_jsbytes("https://carthagenet.tzstats.com/"),
     _jA_=caml_string_of_jsbytes("TzStats"),
     _jB_=caml_string_of_jsbytes("injection progressing: "),
     _jt_=caml_string_of_jsbytes("unknown injtoken: "),
     _jm_=caml_string_of_jsbytes("injtoken"),
     _jl_=caml_string_of_jsbytes("injtoken"),
     _ji_=
      [0,
       [11,caml_string_of_jsbytes("now: "),[8,[0,0,0],0,0,0]],
       caml_string_of_jsbytes("now: %f")],
     _jj_=
      [0,
       [11,caml_string_of_jsbytes("timeout: "),[8,[0,0,0],0,0,0]],
       caml_string_of_jsbytes("timeout: %f")],
     _jf_=caml_string_of_jsbytes("minqueryinterval"),
     _jg_=caml_string_of_jsbytes("timeout"),
     _jh_=caml_string_of_jsbytes("injtoken"),
     _jc_=caml_string_of_jsbytes("injtoken"),
     _jd_=caml_string_of_jsbytes("timeout"),
     _je_=caml_string_of_jsbytes("minqueryinterval"),
     _i6_=caml_string_of_jsbytes("network"),
     _i7_=caml_string_of_jsbytes("signature"),
     _i8_=caml_string_of_jsbytes("srcaddr"),
     _i9_=caml_string_of_jsbytes("signer"),
     _i__=caml_string_of_jsbytes("unsignedtxn"),
     _i1_=caml_string_of_jsbytes("unsignedtxn"),
     _i2_=caml_string_of_jsbytes("signer"),
     _i3_=caml_string_of_jsbytes("srcaddr"),
     _i4_=caml_string_of_jsbytes("signature"),
     _i5_=caml_string_of_jsbytes("network"),
     _iT_=caml_string_of_jsbytes("spell not valid according to "),
     _iR_=[254,0.572,2.3],
     _iS_=[0,0.,[254,0.001283,0.],0],
     _iO_=caml_string_of_jsbytes("MOCK_tmplversion_proto0_frozen"),
     _iP_=caml_string_of_jsbytes("MOCK_bookhash_proto0_frozen"),
     _iQ_=caml_string_of_jsbytes("MOCK_sahash_proto0_frozen_genesis"),
     _iU_=caml_string_of_jsbytes("MOCK_sahash_proto0_frozen_withdraw"),
     _iV_=caml_string_of_jsbytes("unsupport tmplversion in proto0 api"),
     _iL_=caml_string_of_jsbytes("simprivinfo"),
     _iM_=caml_string_of_jsbytes("txn"),
     _iN_=caml_string_of_jsbytes("network"),
     _iI_=caml_string_of_jsbytes("network"),
     _iJ_=caml_string_of_jsbytes("txn"),
     _iK_=caml_string_of_jsbytes("simprivinfo"),
     _iD_=caml_string_of_jsbytes("simprivinfo"),
     _iE_=caml_string_of_jsbytes("unsignedtxn"),
     _iB_=caml_string_of_jsbytes("unsignedtxn"),
     _iC_=caml_string_of_jsbytes("simprivinfo"),
     _iy_=caml_string_of_jsbytes("unexpected network for proto0"),
     _iv_=caml_string_of_jsbytes("target"),
     _iw_=caml_string_of_jsbytes("txn"),
     _ix_=caml_string_of_jsbytes("spell"),
     _is_=caml_string_of_jsbytes("spell"),
     _it_=caml_string_of_jsbytes("txn"),
     _iu_=caml_string_of_jsbytes("target"),
     _io_=caml_string_of_jsbytes("verifier"),
     _in_=caml_string_of_jsbytes("verifier"),
     _il_=caml_string_of_jsbytes("sahash"),
     _ik_=caml_string_of_jsbytes("sahash"),
     _ic_=caml_string_of_jsbytes(""),
     _h$_=caml_string_of_jsbytes("bookhash"),
     _h__=caml_string_of_jsbytes("bookhash"),
     _h8_=caml_string_of_jsbytes("bookhash"),
     _h7_=caml_string_of_jsbytes("bookhash"),
     _h5_=caml_string_of_jsbytes("provider"),
     _h4_=caml_string_of_jsbytes("provider"),
     _h2_=caml_string_of_jsbytes("specifications"),
     _h1_=caml_string_of_jsbytes("specifications"),
     _hZ_=caml_string_of_jsbytes("bookhash"),
     _hY_=caml_string_of_jsbytes("bookhash"),
     _hW_=caml_string_of_jsbytes("books"),
     _hV_=caml_string_of_jsbytes("books"),
     _hT_=caml_string_of_jsbytes("networks"),
     _hS_=caml_string_of_jsbytes("networks"),
     _hQ_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _hK_=[0,caml_string_of_jsbytes("getBook")],
     _hL_=
      [0,
       caml_string_of_jsbytes("simulateOperation"),
       caml_string_of_jsbytes("injectOperation"),
       caml_string_of_jsbytes("getSpellVerifier"),
       caml_string_of_jsbytes("forgeOperation"),
       caml_string_of_jsbytes("defaultClerkUserInfo"),
       caml_string_of_jsbytes("checkOperationInjection")],
     _hM_=
      [0,
       caml_string_of_jsbytes("getProviderInfo"),
       caml_string_of_jsbytes("listAvailableTezosNetworks"),
       caml_string_of_jsbytes("getBookStatus"),
       caml_string_of_jsbytes("getBookReferences"),
       caml_string_of_jsbytes("listAdvertizedBooks"),
       caml_string_of_jsbytes("getBookCharges")],
     _hN_=
      [0,
       caml_string_of_jsbytes("calculateAddressFromPublicKey"),
       caml_string_of_jsbytes("calculateAddressFromPublicKeyAsync")],
     _hO_=
      [0,
       caml_string_of_jsbytes("simulateOperation"),
       caml_string_of_jsbytes("injectOperation"),
       caml_string_of_jsbytes("getSpellVerifier"),
       caml_string_of_jsbytes("checkOperationInjection"),
       caml_string_of_jsbytes("defaultClerkUserInfo"),
       caml_string_of_jsbytes("forgeOperation")],
     _hP_=
      [0,
       caml_string_of_jsbytes("listAvailableTezosNetworks"),
       caml_string_of_jsbytes("listAdvertizedBooks"),
       caml_string_of_jsbytes("getProviderInfo"),
       caml_string_of_jsbytes("getBookStatus"),
       caml_string_of_jsbytes("getBookReferences"),
       caml_string_of_jsbytes("getBookCharges")],
     _hR_=caml_string_of_jsbytes("networks"),
     _hU_=caml_string_of_jsbytes("books"),
     _hX_=caml_string_of_jsbytes("bookhash"),
     _h0_=caml_string_of_jsbytes("specifications"),
     _h3_=caml_string_of_jsbytes("provider"),
     _h6_=caml_string_of_jsbytes("bookhash"),
     _h9_=caml_string_of_jsbytes("bookhash"),
     _ij_=caml_string_of_jsbytes("sahash"),
     _im_=caml_string_of_jsbytes("verifier"),
     _ip_=caml_string_of_jsbytes("target"),
     _iq_=caml_string_of_jsbytes("txn"),
     _ir_=caml_string_of_jsbytes("spell"),
     _iz_=caml_string_of_jsbytes("simprivinfo"),
     _iA_=caml_string_of_jsbytes("unsignedtxn"),
     _iF_=caml_string_of_jsbytes("simprivinfo"),
     _iG_=caml_string_of_jsbytes("txn"),
     _iH_=caml_string_of_jsbytes("network"),
     _iW_=caml_string_of_jsbytes("network"),
     _iX_=caml_string_of_jsbytes("signature"),
     _iY_=caml_string_of_jsbytes("srcaddr"),
     _iZ_=caml_string_of_jsbytes("signer"),
     _i0_=caml_string_of_jsbytes("unsignedtxn"),
     _i$_=caml_string_of_jsbytes("minqueryinterval"),
     _ja_=caml_string_of_jsbytes("timeout"),
     _jb_=caml_string_of_jsbytes("injtoken"),
     _jk_=caml_string_of_jsbytes("injtoken"),
     _jL_=caml_string_of_jsbytes("bookhash"),
     _j8_=caml_string_of_jsbytes(" loaded"),
     _j9_=caml_string_of_jsbytes("aii/aii_jslib.ml"),
     _kg_=caml_string_of_jsbytes("aii/aii_jslib.ml"),
     _kh_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": entrypoint "),
         [2,0,[11,caml_string_of_jsbytes(" exposed"),0]]]],
       caml_string_of_jsbytes("%s: entrypoint %s exposed")];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    caml_fresh_oo_id(0);
    function abs(x){return 0 <= x?x:- x | 0}
    var max_int_float=2147483647;
    function symbol(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return caml_string_of_bytes(s)}
    function string_of_bool(b){return b?_a_:_b_}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    caml_ml_open_descriptor_in(0);
    var
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_qM_)
             {_qM_ = caml_wrap_exception(_qM_);
              if(_qM_[1] !== Sys_error)throw _qM_;
              var _qL_=_qM_}
            var param$0=l;
            continue}
          return 0}}
      return iter(caml_ml_out_channels_list(0))}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {var g=exit_function[1],f_already_ran=[0,0];
      exit_function[1]
      =
      function(param)
       {if(1 - f_already_ran[1]){f_already_ran[1] = 1;caml_call1(f,0)}
        return caml_call1(g,0)};
      return 0}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    caml_fresh_oo_id(0);
    function value(o,default$0){if(o){var v=o[1];return v}return default$0}
    function map(f,o){if(o){var v=o[1];return [0,caml_call1(f,v)]}return 0}
    function symbol_bind(r,f)
     {if(0 === r[0]){var v=r[1];return caml_call1(f,v)}return r}
    var
     match=caml_sys_const_backend_type(0),
     max_array_length=caml_sys_const_max_wosize(0),
     max_string_length=(4 * max_array_length | 0) - 1 | 0;
    caml_fresh_oo_id(0);
    typeof match === "number";
    function map$0(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map$0(f,l)]}
      return 0}
    function make(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    var empty_return=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function to_string(b){return caml_string_of_bytes(copy(b))}
    function of_string(s){return copy(caml_bytes_of_string(s))}
    function sub(s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       {var r=caml_create_bytes(len);caml_blit_bytes(s,ofs,r,0,len);return r}
      return invalid_arg(_l_)}
    function sub_string(b,ofs,len)
     {return caml_string_of_bytes(sub(b,ofs,len))}
    function blit(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_bytes_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(_m_)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_string_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(_n_)}
    function make$0(n,c){return caml_string_of_bytes(make(n,c))}
    function sub$0(s,ofs,len)
     {return caml_string_of_bytes(sub(caml_bytes_of_string(s),ofs,len))}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function contains_from(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec(s,l,i,c);var _qJ_=1;return _qJ_}
       catch(_qK_)
        {_qK_ = caml_wrap_exception(_qK_);
         if(_qK_ === Not_found)return 0;
         throw _qK_}
      return invalid_arg(_o_)}
    function contains(s,c){return contains_from(s,0,c)}
    function map$1(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_qH_=l - 1 | 0,_qG_=1;
      if(! (_qH_ < 1))
       {var i=_qG_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _qI_=i + 1 | 0;
          if(_qH_ !== i){var i=_qI_;continue}
          break}}
      return r}
    function to_list(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[1 + i],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function of_list(l)
     {if(l)
       {var tl=l[2],hd=l[1],accu=0,param=l;
        for(;;)
         {if(param)
           {var
             param$0=param[2],
             accu$0=accu + 1 | 0,
             accu=accu$0,
             param=param$0;
            continue}
          var a=caml_make_vect(accu,hd),i=1,param$1=tl;
          for(;;)
           {if(param$1)
             {var tl$0=param$1[2],hd$0=param$1[1];
              a[1 + i] = hd$0;
              var i$0=i + 1 | 0,i=i$0,param$1=tl$0;
              continue}
            return a}}}
      return [0]}
    caml_fresh_oo_id(0);
    function _z_(Ord)
     {function height(param){if(param){var h=param[5];return h}return 0}
      function create(l,x,d,r)
       {var hl=height(l),hr=height(r),_qF_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
        return [0,l,x,d,r,_qF_]}
      function singleton(x,d){return [0,0,x,d,0,1]}
      function bal(l,x,d,r)
       {if(l)var h=l[5],hl=h;else var hl=0;
        if(r)var h$0=r[5],hr=h$0;else var hr=0;
        if((hr + 2 | 0) < hl)
         {if(l)
           {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_qA_=height(lr);
            if(_qA_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
            if(lr)
             {var
               lrr=lr[4],
               lrd=lr[3],
               lrv=lr[2],
               lrl=lr[1],
               _qB_=create(lrr,x,d,r);
              return create(create(ll,lv,ld,lrl),lrv,lrd,_qB_)}
            return invalid_arg(_r_)}
          return invalid_arg(_s_)}
        if((hl + 2 | 0) < hr)
         {if(r)
           {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_qC_=height(rl);
            if(_qC_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
            if(rl)
             {var
               rlr=rl[4],
               rld=rl[3],
               rlv=rl[2],
               rll=rl[1],
               _qD_=create(rlr,rv,rd,rr);
              return create(create(l,x,d,rll),rlv,rld,_qD_)}
            return invalid_arg(_t_)}
          return invalid_arg(_u_)}
        var _qE_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
        return [0,l,x,d,r,_qE_]}
      var empty=0;
      function is_empty(param){return param?0:1}
      function add(x,data,m)
       {if(m)
         {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
          if(0 === c)return d === data?m:[0,l,x,data,r,h];
          if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
          var ll=add(x,data,l);
          return l === ll?m:bal(ll,v,d,r)}
        return [0,0,x,data,0,1]}
      function find(x,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             l=param$0[1],
             c=caml_call2(Ord[1],x,v);
            if(0 === c)return d;
            var param$1=0 <= c?r:l,param$0=param$1;
            continue}
          throw Not_found}}
      function find_first(f,param$0)
       {var param$1=param$0;
        for(;;)
         {if(param$1)
           {var r$0=param$1[4],d$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
            if(caml_call1(f,v$0))
             {var v0=v$0,d0=d$0,param=l$0;
              for(;;)
               {if(param)
                 {var r=param[4],d=param[3],v=param[2],l=param[1];
                  if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                  var param=r;
                  continue}
                return [0,v0,d0]}}
            var param$1=r$0;
            continue}
          throw Not_found}}
      function find_first_opt(f,param$0)
       {var param$1=param$0;
        for(;;)
         {if(param$1)
           {var r$0=param$1[4],d$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
            if(caml_call1(f,v$0))
             {var v0=v$0,d0=d$0,param=l$0;
              for(;;)
               {if(param)
                 {var r=param[4],d=param[3],v=param[2],l=param[1];
                  if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                  var param=r;
                  continue}
                return [0,[0,v0,d0]]}}
            var param$1=r$0;
            continue}
          return 0}}
      function find_last(f,param$0)
       {var param$1=param$0;
        for(;;)
         {if(param$1)
           {var r$0=param$1[4],d$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
            if(caml_call1(f,v$0))
             {var v0=v$0,d0=d$0,param=r$0;
              for(;;)
               {if(param)
                 {var r=param[4],d=param[3],v=param[2],l=param[1];
                  if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                  var param=l;
                  continue}
                return [0,v0,d0]}}
            var param$1=l$0;
            continue}
          throw Not_found}}
      function find_last_opt(f,param$0)
       {var param$1=param$0;
        for(;;)
         {if(param$1)
           {var r$0=param$1[4],d$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
            if(caml_call1(f,v$0))
             {var v0=v$0,d0=d$0,param=r$0;
              for(;;)
               {if(param)
                 {var r=param[4],d=param[3],v=param[2],l=param[1];
                  if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                  var param=l;
                  continue}
                return [0,[0,v0,d0]]}}
            var param$1=l$0;
            continue}
          return 0}}
      function find_opt(x,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             l=param$0[1],
             c=caml_call2(Ord[1],x,v);
            if(0 === c)return [0,d];
            var param$1=0 <= c?r:l,param$0=param$1;
            continue}
          return 0}}
      function mem(x,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             v=param$0[2],
             l=param$0[1],
             c=caml_call2(Ord[1],x,v),
             _qz_=0 === c?1:0;
            if(_qz_)return _qz_;
            var param$1=0 <= c?r:l,param$0=param$1;
            continue}
          return 0}}
      function min_binding(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var _qy_=param$0[1];
            if(_qy_){var param$0=_qy_;continue}
            var d=param$0[3],v=param$0[2];
            return [0,v,d]}
          throw Not_found}}
      function min_binding_opt(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var _qx_=param$0[1];
            if(_qx_){var param$0=_qx_;continue}
            var d=param$0[3],v=param$0[2];
            return [0,[0,v,d]]}
          return 0}}
      function max_binding(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
            var d=param$0[3],v=param$0[2];
            return [0,v,d]}
          throw Not_found}}
      function max_binding_opt(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
            var d=param$0[3],v=param$0[2];
            return [0,[0,v,d]]}
          return 0}}
      function remove_min_binding(param)
       {if(param)
         {var _qw_=param[1];
          if(_qw_)
           {var r=param[4],d=param[3],v=param[2];
            return bal(remove_min_binding(_qw_),v,d,r)}
          var r$0=param[4];
          return r$0}
        return invalid_arg(_v_)}
      function _p$_(t,match)
       {if(t)
         {if(match)
           {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
            return bal(t,x,d,remove_min_binding(match))}
          return t}
        return match}
      function remove(x,m)
       {if(m)
         {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
          if(0 === c)return _p$_(l,r);
          if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
          var ll=remove(x,l);
          return l === ll?m:bal(ll,v,d,r)}
        return 0}
      function update(x,f,m)
       {if(m)
         {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
          if(0 === c)
           {var match=caml_call1(f,[0,d]);
            if(match){var data=match[1];return d === data?m:[0,l,x,data,r,h]}
            return _p$_(l,r)}
          if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
          var ll=update(x,f,l);
          return l === ll?m:bal(ll,v,d,r)}
        var match$0=caml_call1(f,0);
        if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
        return 0}
      function iter(f,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
            iter(f,l);
            caml_call2(f,v,d);
            var param$0=r;
            continue}
          return 0}}
      function map(f,param)
       {if(param)
         {var
           h=param[5],
           r=param[4],
           d=param[3],
           v=param[2],
           l=param[1],
           l$0=map(f,l),
           d$0=caml_call1(f,d),
           r$0=map(f,r);
          return [0,l$0,v,d$0,r$0,h]}
        return 0}
      function mapi(f,param)
       {if(param)
         {var
           h=param[5],
           r=param[4],
           d=param[3],
           v=param[2],
           l=param[1],
           l$0=mapi(f,l),
           d$0=caml_call2(f,v,d),
           r$0=mapi(f,r);
          return [0,l$0,v,d$0,r$0,h]}
        return 0}
      function fold(f,m,accu)
       {var m$0=m,accu$0=accu;
        for(;;)
         {if(m$0)
           {var
             r=m$0[4],
             d=m$0[3],
             v=m$0[2],
             l=m$0[1],
             accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
             m$0=r,
             accu$0=accu$1;
            continue}
          return accu$0}}
      function for_all(p,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             l=param$0[1],
             _qt_=caml_call2(p,v,d);
            if(_qt_)
             {var _qu_=for_all(p,l);
              if(_qu_){var param$0=r;continue}
              var _qv_=_qu_}
            else
             var _qv_=_qt_;
            return _qv_}
          return 1}}
      function exists(p,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             l=param$0[1],
             _qq_=caml_call2(p,v,d);
            if(_qq_)
             var _qr_=_qq_;
            else
             {var _qs_=exists(p,l);
              if(! _qs_){var param$0=r;continue}
              var _qr_=_qs_}
            return _qr_}
          return 0}}
      function add_min_binding(k,x,param)
       {if(param)
         {var r=param[4],d=param[3],v=param[2],l=param[1];
          return bal(add_min_binding(k,x,l),v,d,r)}
        return singleton(k,x)}
      function add_max_binding(k,x,param)
       {if(param)
         {var r=param[4],d=param[3],v=param[2],l=param[1];
          return bal(l,v,d,add_max_binding(k,x,r))}
        return singleton(k,x)}
      function join(l,v,d,r)
       {if(l)
         {if(r)
           {var
             rh=r[5],
             rr=r[4],
             rd=r[3],
             rv=r[2],
             rl=r[1],
             lh=l[5],
             lr=l[4],
             ld=l[3],
             lv=l[2],
             ll=l[1];
            return (rh + 2 | 0) < lh
                    ?bal(ll,lv,ld,join(lr,v,d,r))
                    :(lh + 2 | 0) < rh
                      ?bal(join(l,v,d,rl),rv,rd,rr)
                      :create(l,v,d,r)}
          return add_max_binding(v,d,l)}
        return add_min_binding(v,d,r)}
      function concat(t,match)
       {if(t)
         {if(match)
           {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
            return join(t,x,d,remove_min_binding(match))}
          return t}
        return match}
      function concat_or_join(t1,v,d,t2)
       {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
      function split(x,param)
       {if(param)
         {var
           r=param[4],
           d=param[3],
           v=param[2],
           l=param[1],
           c=caml_call2(Ord[1],x,v);
          if(0 === c)return [0,l,[0,d],r];
          if(0 <= c)
           {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
            return [0,join(l,v,d,lr),pres,rr]}
          var
           match$0=split(x,l),
           rl=match$0[3],
           pres$0=match$0[2],
           ll=match$0[1];
          return [0,ll,pres$0,join(rl,v,d,r)]}
        return _w_}
      function merge(f,s1,s2)
       {if(s1)
         {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
          if(height(s2) <= h1)
           {var
             match=split(v1,s2),
             r2=match[3],
             d2=match[2],
             l2=match[1],
             _qm_=merge(f,r1,r2),
             _qn_=caml_call3(f,v1,[0,d1],d2);
            return concat_or_join(merge(f,l1,l2),v1,_qn_,_qm_)}}
        else
         if(! s2)return 0;
        if(s2)
         {var
           r2$0=s2[4],
           d2$0=s2[3],
           v2=s2[2],
           l2$0=s2[1],
           match$0=split(v2,s1),
           r1$0=match$0[3],
           d1$0=match$0[2],
           l1$0=match$0[1],
           _qo_=merge(f,r1$0,r2$0),
           _qp_=caml_call3(f,v2,d1$0,[0,d2$0]);
          return concat_or_join(merge(f,l1$0,l2$0),v2,_qp_,_qo_)}
        throw [0,Assert_failure,_x_]}
      function union(f,s1,s2)
       {if(s1)
         {if(s2)
           {var
             h2=s2[5],
             r2=s2[4],
             d2=s2[3],
             v2=s2[2],
             l2=s2[1],
             h1=s1[5],
             r1=s1[4],
             d1=s1[3],
             v1=s1[2],
             l1=s1[1];
            if(h2 <= h1)
             {var
               match=split(v1,s2),
               r2$0=match[3],
               d2$0=match[2],
               l2$0=match[1],
               l=union(f,l1,l2$0),
               r=union(f,r1,r2$0);
              if(d2$0)
               {var d2$1=d2$0[1];
                return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
              return join(l,v1,d1,r)}
            var
             match$0=split(v2,s1),
             r1$0=match$0[3],
             d1$0=match$0[2],
             l1$0=match$0[1],
             l$0=union(f,l1$0,l2),
             r$0=union(f,r1$0,r2);
            if(d1$0)
             {var d1$1=d1$0[1];
              return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
            return join(l$0,v2,d2,r$0)}
          var s=s1}
        else
         var s=s2;
        return s}
      function filter(p,m)
       {if(m)
         {var
           r=m[4],
           d=m[3],
           v=m[2],
           l=m[1],
           l$0=filter(p,l),
           pvd=caml_call2(p,v,d),
           r$0=filter(p,r);
          if(pvd){if(l === l$0 && r === r$0)return m;return join(l$0,v,d,r$0)}
          return concat(l$0,r$0)}
        return 0}
      function partition(p,param)
       {if(param)
         {var
           r=param[4],
           d=param[3],
           v=param[2],
           l=param[1],
           match=partition(p,l),
           lf=match[2],
           lt=match[1],
           pvd=caml_call2(p,v,d),
           match$0=partition(p,r),
           rf=match$0[2],
           rt=match$0[1];
          if(pvd){var _qk_=concat(lf,rf);return [0,join(lt,v,d,rt),_qk_]}
          var _ql_=join(lf,v,d,rf);
          return [0,concat(lt,rt),_ql_]}
        return _y_}
      function cons_enum(m,e)
       {var m$0=m,e$0=e;
        for(;;)
         {if(m$0)
           {var
             r=m$0[4],
             d=m$0[3],
             v=m$0[2],
             m$1=m$0[1],
             e$1=[0,v,d,r,e$0],
             m$0=m$1,
             e$0=e$1;
            continue}
          return e$0}}
      function compare(cmp,m1,m2)
       {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
        for(;;)
         {if(e1)
           {if(e2)
             {var
               e2$0=e2[4],
               r2=e2[3],
               d2=e2[2],
               v2=e2[1],
               e1$0=e1[4],
               r1=e1[3],
               d1=e1[2],
               v1=e1[1],
               c=caml_call2(Ord[1],v1,v2);
              if(0 === c)
               {var c$0=caml_call2(cmp,d1,d2);
                if(0 === c$0)
                 {var
                   e2$1=cons_enum(r2,e2$0),
                   e1$1=cons_enum(r1,e1$0),
                   e1=e1$1,
                   e2=e2$1;
                  continue}
                return c$0}
              return c}
            return 1}
          return e2?-1:0}}
      function equal(cmp,m1,m2)
       {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
        for(;;)
         {if(e1)
           {if(e2)
             {var
               e2$0=e2[4],
               r2=e2[3],
               d2=e2[2],
               v2=e2[1],
               e1$0=e1[4],
               r1=e1[3],
               d1=e1[2],
               v1=e1[1],
               _qh_=0 === caml_call2(Ord[1],v1,v2)?1:0;
              if(_qh_)
               {var _qi_=caml_call2(cmp,d1,d2);
                if(_qi_)
                 {var
                   e2$1=cons_enum(r2,e2$0),
                   e1$1=cons_enum(r1,e1$0),
                   e1=e1$1,
                   e2=e2$1;
                  continue}
                var _qj_=_qi_}
              else
               var _qj_=_qh_;
              return _qj_}
            return 0}
          return e2?0:1}}
      function cardinal(param)
       {if(param)
         {var r=param[4],l=param[1],_qg_=cardinal(r);
          return (cardinal(l) + 1 | 0) + _qg_ | 0}
        return 0}
      function bindings_aux(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             r=param$0[4],
             d=param$0[3],
             v=param$0[2],
             l=param$0[1],
             accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
             accu$0=accu$1,
             param$0=l;
            continue}
          return accu$0}}
      function bindings(s){return bindings_aux(0,s)}
      function add_seq(i,m)
       {var acc=m,seq=i;
        for(;;)
         {var match=caml_call1(seq,0);
          if(match)
           {var
             next=match[2],
             x=match[1],
             v=x[2],
             k=x[1],
             acc$0=add(k,v,acc),
             acc=acc$0,
             seq=next;
            continue}
          return acc}}
      function of_seq(i){return add_seq(i,empty)}
      function seq_of_enum(c,param)
       {if(c)
         {var rest=c[4],t=c[3],v=c[2],k=c[1],_qe_=cons_enum(t,rest);
          return [0,[0,k,v],function(_qf_){return seq_of_enum(_qe_,_qf_)}]}
        return 0}
      function to_seq(m)
       {var _qc_=cons_enum(m,0);
        return function(_qd_){return seq_of_enum(_qc_,_qd_)}}
      function to_seq_from(low,m)
       {var m$0=m,c=0;
        for(;;)
         {if(m$0)
           {var
             r=m$0[4],
             d=m$0[3],
             v=m$0[2],
             l=m$0[1],
             n=caml_call2(Ord[1],v,low);
            if(0 !== n)
             {if(0 <= n){var c$0=[0,v,d,r,c],m$0=l,c=c$0;continue}
              var m$0=r;
              continue}
            var _qa_=[0,v,d,r,c]}
          else
           var _qa_=c;
          return function(_qb_){return seq_of_enum(_qa_,_qb_)}}}
      return [0,
              empty,
              is_empty,
              mem,
              add,
              update,
              singleton,
              remove,
              merge,
              union,
              compare,
              equal,
              iter,
              fold,
              for_all,
              exists,
              filter,
              partition,
              cardinal,
              bindings,
              min_binding,
              min_binding_opt,
              max_binding,
              max_binding_opt,
              min_binding,
              min_binding_opt,
              split,
              find,
              find_opt,
              find_first,
              find_first_opt,
              find_last,
              find_last_opt,
              map,
              mapi,
              to_seq,
              to_seq_from,
              add_seq,
              of_seq]}
    caml_fresh_oo_id(0);
    function create(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop_opt(s)
     {var _p__=s[1];
      if(_p__)
       {var tl=_p__[2],hd=_p__[1];s[1] = tl;s[2] = s[2] - 1 | 0;return [0,hd]}
      return 0}
    function top_opt(s)
     {var _p9_=s[1];if(_p9_){var hd=_p9_[1];return [0,hd]}return 0}
    var Empty=[248,_A_,caml_fresh_oo_id(0)];
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_p8_=q[3];
      return _p8_
              ?(q[1] = q[1] + 1 | 0,_p8_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    var Undefined=[248,_B_,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        caml_obj_make_forward(blk,result);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function create$0(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function resize(b,more)
     {var old_pos=b[2],old_len=b[3],new_len=[0,old_len];
      for(;;)
       {if(new_len[1] < (old_pos + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((old_pos + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(_F_);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        if((b[2] + more | 0) <= b[3])
         {if((old_pos + more | 0) <= b[3])return 0;
          throw [0,Assert_failure,_D_]}
        throw [0,Assert_failure,_E_]}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function default_float_precision(fconv){return 5 === fconv[2]?12:-6}
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       y=buf[1] + overhead | 0,
       _p6_=len < y?1:0;
      if(_p6_)
       {var
         x=len * 2 | 0,
         new_len=caml_greaterequal(x,y)?x:y,
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _p7_=0}
      else
       var _p7_=_p6_;
      return _p7_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return _H_;
         case 1:return _I_;
         case 2:return _J_;
         case 3:return _K_;
         case 4:return _L_;
         case 5:return _M_;
         default:return _N_}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return symbol(_O_,make$0(1,c))}}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,_P_);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,_Q_);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,_R_);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,_S_);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,_T_);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,_U_);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,_V_);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,_W_);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,_X_);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,_Y_);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,_Z_);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,___);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,_$_);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,_aa_);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,_ab_);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,_ac_);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,_ad_);
           var fmtty$0=rest$13;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _pI_=function(param){return 0},
         _pJ_=function(param){return 0},
         _pK_=function(param){return 0};
        return [0,function(param){return 0},_pK_,_pJ_,_pI_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _pL_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_pL_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _pM_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _pM_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _pN_=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _pN_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _pO_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _pO_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _pP_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _pP_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _pQ_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _pQ_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _pR_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _pR_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _pS_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _pS_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _pT_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _pT_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _pU_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _pV_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _pW_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _pW_,
                  _pV_,
                  _pU_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _pX_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _pX_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _pY_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _pY_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _pZ_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _pZ_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _p0_=function(param){caml_call1(de$12,0);return 0},
           _p1_=function(param){caml_call1(ed$12,0);return 0},
           _p2_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _p2_,
                  _p1_,
                  _p0_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _p3_=function(param){caml_call1(de$13,0);return 0},
           _p4_=function(param){caml_call1(ed$13,0);return 0},
           _p5_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _p5_,
                  _p4_,
                  _p3_]}}
    function trans(ty1,match)
     {var switch$0=0;
      if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:break;
          case 11:switch$0 = 1;break;
          case 12:switch$0 = 2;break;
          case 13:switch$0 = 3;break;
          case 14:switch$0 = 4;break;
          case 8:switch$0 = 5;break;
          case 9:switch$0 = 6;break;
          default:throw [0,Assert_failure,_ae_]}
      else
       switch(ty1[0])
        {case 0:
          var switch$1=0,_pp_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_pp_,rest2)];
             case 8:switch$0 = 5;switch$1 = 1;break;
             case 9:switch$0 = 6;switch$1 = 1;break;
             case 10:switch$1 = 1;break;
             case 11:switch$0 = 1;switch$1 = 1;break;
             case 12:switch$0 = 2;switch$1 = 1;break;
             case 13:switch$0 = 3;switch$1 = 1;break;
             case 14:switch$0 = 4;switch$1 = 1;break
             }
          if(! switch$1)switch$0 = 7;
          break;
         case 1:
          var switch$2=0,_pq_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_pq_,rest2$0)];
             case 8:switch$0 = 5;switch$2 = 1;break;
             case 9:switch$0 = 6;switch$2 = 1;break;
             case 10:switch$2 = 1;break;
             case 11:switch$0 = 1;switch$2 = 1;break;
             case 12:switch$0 = 2;switch$2 = 1;break;
             case 13:switch$0 = 3;switch$2 = 1;break;
             case 14:switch$0 = 4;switch$2 = 1;break
             }
          if(! switch$2)switch$0 = 7;
          break;
         case 2:
          var switch$3=0,_pr_=ty1[1];
          if(typeof match === "number")
           switch$3 = 1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_pr_,rest2$1)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$3 = 1}
          if(switch$3)switch$0 = 7;
          break;
         case 3:
          var switch$4=0,_ps_=ty1[1];
          if(typeof match === "number")
           switch$4 = 1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_ps_,rest2$2)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$4 = 1}
          if(switch$4)switch$0 = 7;
          break;
         case 4:
          var switch$5=0,_pt_=ty1[1];
          if(typeof match === "number")
           switch$5 = 1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_pt_,rest2$3)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$5 = 1}
          if(switch$5)switch$0 = 7;
          break;
         case 5:
          var switch$6=0,_pu_=ty1[1];
          if(typeof match === "number")
           switch$6 = 1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_pu_,rest2$4)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$6 = 1}
          if(switch$6)switch$0 = 7;
          break;
         case 6:
          var switch$7=0,_pv_=ty1[1];
          if(typeof match === "number")
           switch$7 = 1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_pv_,rest2$5)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$7 = 1}
          if(switch$7)switch$0 = 7;
          break;
         case 7:
          var switch$8=0,_pw_=ty1[1];
          if(typeof match === "number")
           switch$8 = 1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_pw_,rest2$6)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$8 = 1}
          if(switch$8)switch$0 = 7;
          break;
         case 8:
          var switch$9=0,_px_=ty1[2],_py_=ty1[1];
          if(typeof match === "number")
           switch$9 = 1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_pz_=trans(_px_,rest2$7);
              return [8,trans(_py_,ty2),_pz_];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$9 = 1}
          if(switch$9)throw [0,Assert_failure,_an_];
          break;
         case 9:
          var switch$10=0,_pA_=ty1[3],_pB_=ty1[2],_pC_=ty1[1];
          if(typeof match === "number")
           switch$10 = 1;
          else
           switch(match[0])
            {case 8:switch$0 = 5;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_pB_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_pC_,ty22,trans(_pA_,rest2$8)];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$10 = 1}
          if(switch$10)throw [0,Assert_failure,_ao_];
          break;
         case 10:
          var _pD_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_pD_,rest2$9)]}
          throw [0,Assert_failure,_ap_];
         case 11:
          var switch$11=0,_pE_=ty1[1];
          if(typeof match === "number")
           switch$11 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:var rest2$10=match[1];return [11,trans(_pE_,rest2$10)];
             default:switch$11 = 1}
          if(switch$11)throw [0,Assert_failure,_aq_];
          break;
         case 12:
          var switch$12=0,_pF_=ty1[1];
          if(typeof match === "number")
           switch$12 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:var rest2$11=match[1];return [12,trans(_pF_,rest2$11)];
             default:switch$12 = 1}
          if(switch$12)throw [0,Assert_failure,_ar_];
          break;
         case 13:
          var switch$13=0,_pG_=ty1[1];
          if(typeof match === "number")
           switch$13 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:var rest2$12=match[1];return [13,trans(_pG_,rest2$12)];
             default:switch$13 = 1}
          if(switch$13)throw [0,Assert_failure,_as_];
          break;
         default:
          var switch$14=0,_pH_=ty1[1];
          if(typeof match === "number")
           switch$14 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:var rest2$13=match[1];return [14,trans(_pH_,rest2$13)];
             default:switch$14 = 1}
          if(switch$14)throw [0,Assert_failure,_at_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_ah_];
        case 1:throw [0,Assert_failure,_ai_];
        case 2:throw [0,Assert_failure,_aj_];
        case 3:throw [0,Assert_failure,_ak_];
        case 4:throw [0,Assert_failure,_al_];
        case 5:throw [0,Assert_failure,_af_];
        case 6:throw [0,Assert_failure,_ag_];
        default:throw [0,Assert_failure,_am_]}}
    var Type_mismatch=[248,_au_,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(prec)
         {var _po_=match[2];
          if(typeof _po_ !== "number" && 2 === _po_[0])
           {var rest=_po_[1],pad$0=match[1];return [0,pad$0,1,rest]}
          throw Type_mismatch}
        var rest$0=match[2],pad$1=match[1];
        return [0,pad$1,0,rest$0]}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           match$1=type_padding(pad,fmtty),
           _o9_=match$1[2],
           _o8_=match$1[1];
          if(typeof _o9_ !== "number" && 1 === _o9_[0])
           {var
             fmtty_rest$1=_o9_[1],
             match$2=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$2[2],
             fmt$2=match$2[1];
            return [0,[2,_o8_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           match$3=type_padding(pad$0,fmtty),
           _o$_=match$3[2],
           _o__=match$3[1];
          if(typeof _o$_ !== "number" && 1 === _o$_[0])
           {var
             fmtty_rest$2=_o$_[1],
             match$4=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$4[2],
             fmt$3=match$4[1];
            return [0,[3,_o__,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           match$5=type_padprec(pad$1,prec,fmtty),
           _pb_=match$5[3],
           _pa_=match$5[1];
          if(typeof _pb_ !== "number" && 2 === _pb_[0])
           {var
             fmtty_rest$3=_pb_[1],
             prec$0=match$5[2],
             match$6=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$6[2],
             fmt$4=match$6[1];
            return [0,[4,iconv,_pa_,prec$0,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$1=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           match$7=type_padprec(pad$2,prec$1,fmtty),
           _pd_=match$7[3],
           _pc_=match$7[1];
          if(typeof _pd_ !== "number" && 3 === _pd_[0])
           {var
             fmtty_rest$4=_pd_[1],
             prec$2=match$7[2],
             match$8=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$8[2],
             fmt$5=match$8[1];
            return [0,[5,iconv$0,_pc_,prec$2,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$3=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           match$9=type_padprec(pad$3,prec$3,fmtty),
           _pf_=match$9[3],
           _pe_=match$9[1];
          if(typeof _pf_ !== "number" && 4 === _pf_[0])
           {var
             fmtty_rest$5=_pf_[1],
             prec$4=match$9[2],
             match$10=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$10[2],
             fmt$6=match$10[1];
            return [0,[6,iconv$1,_pe_,prec$4,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$5=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           match$11=type_padprec(pad$4,prec$5,fmtty),
           _ph_=match$11[3],
           _pg_=match$11[1];
          if(typeof _ph_ !== "number" && 5 === _ph_[0])
           {var
             fmtty_rest$6=_ph_[1],
             prec$6=match$11[2],
             match$12=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$12[2],
             fmt$7=match$12[1];
            return [0,[7,iconv$2,_pg_,prec$6,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$7=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           match$13=type_padprec(pad$5,prec$7,fmtty),
           _pj_=match$13[3],
           _pi_=match$13[1];
          if(typeof _pj_ !== "number" && 6 === _pj_[0])
           {var
             fmtty_rest$7=_pj_[1],
             prec$8=match$13[2],
             match$14=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$14[2],
             fmt$8=match$14[1];
            return [0,[8,fconv,_pi_,prec$8,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           match$15=type_padding(pad$6,fmtty),
           _pl_=match$15[2],
           _pk_=match$15[1];
          if(typeof _pl_ !== "number" && 7 === _pl_[0])
           {var
             fmtty_rest$8=_pl_[1],
             match$16=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$16[2],
             fmt$9=match$16[1];
            return [0,[9,_pk_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$17=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$17[2],
           fmt$10=match$17[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$18=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$18[2],
           fmt$11=match$18[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$19=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$19[2],
           fmt$12=match$19[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$20=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$20[2],
             fmt$13=match$20[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _pm_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_pm_))
             throw Type_mismatch;
            var
             match$21=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$21[2],
             fmt$14=match$21[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$22=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$22[2],
             fmt$15=match$22[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$23=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$23[2],
             fmt$16=match$23[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$24=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$24[2],
           fmt$17=match$24[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$28=formatting_gen[1],
             str$0=match$28[2],
             fmt1=match$28[1],
             match$29=type_format_gen(fmt1,fmtty),
             fmtty2=match$29[2],
             fmt2=match$29[1],
             match$30=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$30[2],
             fmt3=match$30[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$31=formatting_gen[1],
           str$1=match$31[2],
           fmt1$0=match$31[1],
           match$32=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$32[2],
           fmt2$0=match$32[1],
           match$33=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$33[2],
           fmt3$0=match$33[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$25=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$25[2],
             fmt$18=match$25[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$26=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$26[2],
             fmt$19=match$26[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$27=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$27[2],
             fmt$20=match$27[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$34=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$34[2],
                 fmt$21=match$34[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _pn_=type_ignored_format_substituti(sub_fmtty$3,rest,fmtty),
               match$35=_pn_[2],
               fmtty$22=match$35[2],
               fmt$22=match$35[1],
               sub_fmtty$4=_pn_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_format_substituti(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substituti(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substituti
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substituti
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substituti
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substituti
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substituti
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substituti
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substituti
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substituti
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _o6_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_o6_))
             throw Type_mismatch;
            var _o7_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_o7_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substituti
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substituti
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substituti
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substituti
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substituti
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _o5_=2 === padty$0?48:32,res=make(width$0,_o5_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         var switch$0=0;
         if(0 < len)
          {var switch$1=0;
           if
            (43
             !==
             caml_string_get(str,0)
             &&
             45
             !==
             caml_string_get(str,0)
             &&
             32
             !==
             caml_string_get(str,0))
            {switch$0 = 1;switch$1 = 1}
           if(! switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0)}}
         else
          switch$0 = 1;
         if(switch$0)
          {var switch$2=0;
           if(1 < len && 48 === caml_string_get(str,0))
            {var switch$3=0;
             if
              (120
               !==
               caml_string_get(str,1)
               &&
               88
               !==
               caml_string_get(str,1))
              {switch$2 = 1;switch$3 = 1}
             if(! switch$3)
              {caml_bytes_set(res,1,caml_string_get(str,1));
               blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0)}}
           else
            switch$2 = 1;
           if(switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return caml_string_of_bytes(res)}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0),
       switch$0=0;
      if(58 <= c)
       {if(71 <= c)
         {if(! (5 < (c - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= c)switch$0 = 1}
      else
       {var switch$1=0;
        if(32 !== c)
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0) && 1 < len)
               {var switch$2=0;
                if
                 (120
                  ===
                  caml_string_get(str,1)
                  ||
                  88
                  ===
                  caml_string_get(str,1))
                 switch$2 = 1;
                if(switch$2)
                 {var res$1=make(prec$0 + 2 | 0,48);
                  caml_bytes_set(res$1,1,caml_string_get(str,1));
                  blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                  return caml_string_of_bytes(res$1)}}
              switch$0 = 1;
              switch$1 = 1;
              break;
             case 0:
             case 2:break;
             case 1:
             case 3:
             case 4:switch$1 = 1;break;
             default:switch$0 = 1;switch$1 = 1}}
         else
          switch$1 = 1;
        if(! switch$1 && len < (prec$0 + 1 | 0))
         {var res$0=make(prec$0 + 1 | 0,48);
          caml_bytes_set(res$0,0,c);
          blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
          return caml_string_of_bytes(res$0)}}
      if(switch$0 && len < prec$0)
       {var res=make(prec$0,48);
        blit$0(str,0,res,prec$0 - len | 0,len);
        return caml_string_of_bytes(res)}
      return str}
    function string_to_caml_string(str)
     {var n$0=caml_ml_string_length(str),i$1=0;
      for(;;)
       {if(n$0 <= i$1)
         var str$0=str;
        else
         {var
           match$0=caml_string_unsafe_get(str,i$1),
           _o3_=match$0 - 32 | 0,
           switch$0=0;
          if(59 < _o3_ >>> 0)
           {if(33 < (_o3_ - 61 | 0) >>> 0)switch$0 = 1}
          else
           if(2 === _o3_)switch$0 = 1;
          if(! switch$0){var i$2=i$1 + 1 | 0,i$1=i$2;continue}
          var
           s$0=caml_bytes_of_string(str),
           n=[0,0],
           _oW_=caml_ml_bytes_length(s$0) - 1 | 0,
           _oV_=0;
          if(! (_oW_ < 0))
           {var i$0=_oV_;
            for(;;)
             {var match=caml_bytes_unsafe_get(s$0,i$0),switch$1=0;
              if(32 <= match)
               {var _o0_=match - 34 | 0,switch$2=0;
                if(58 < _o0_ >>> 0)
                 {if(93 <= _o0_)switch$2 = 1}
                else
                 if(56 < (_o0_ - 1 | 0) >>> 0){switch$1 = 1;switch$2 = 1}
                if(! switch$2){var _o1_=1;switch$1 = 2}}
              else
               if(11 <= match)
                {if(13 === match)switch$1 = 1}
               else
                if(8 <= match)switch$1 = 1;
              switch(switch$1)
               {case 0:var _o1_=4;break;case 1:var _o1_=2;break}
              n[1] = n[1] + _o1_ | 0;
              var _o2_=i$0 + 1 | 0;
              if(_oW_ !== i$0){var i$0=_o2_;continue}
              break}}
          if(n[1] === caml_ml_bytes_length(s$0))
           var _o4_=copy(s$0);
          else
           {var s=caml_create_bytes(n[1]);
            n[1] = 0;
            var _oY_=caml_ml_bytes_length(s$0) - 1 | 0,_oX_=0;
            if(! (_oY_ < 0))
             {var i=_oX_;
              for(;;)
               {var c=caml_bytes_unsafe_get(s$0,i),switch$3=0;
                if(35 <= c)
                 if(92 === c)
                  switch$3 = 2;
                 else
                  if(127 <= c)switch$3 = 1;else switch$3 = 3;
                else
                 if(32 <= c)
                  if(34 <= c)switch$3 = 2;else switch$3 = 3;
                 else
                  if(14 <= c)
                   switch$3 = 1;
                  else
                   switch(c)
                    {case 8:
                      caml_bytes_unsafe_set(s,n[1],92);
                      n[1]++;
                      caml_bytes_unsafe_set(s,n[1],98);
                      break;
                     case 9:
                      caml_bytes_unsafe_set(s,n[1],92);
                      n[1]++;
                      caml_bytes_unsafe_set(s,n[1],116);
                      break;
                     case 10:
                      caml_bytes_unsafe_set(s,n[1],92);
                      n[1]++;
                      caml_bytes_unsafe_set(s,n[1],110);
                      break;
                     case 13:
                      caml_bytes_unsafe_set(s,n[1],92);
                      n[1]++;
                      caml_bytes_unsafe_set(s,n[1],114);
                      break;
                     default:switch$3 = 1}
                switch(switch$3)
                 {case 1:
                   caml_bytes_unsafe_set(s,n[1],92);
                   n[1]++;
                   caml_bytes_unsafe_set(s,n[1],48 + (c / 100 | 0) | 0);
                   n[1]++;
                   caml_bytes_unsafe_set
                    (s,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
                   n[1]++;
                   caml_bytes_unsafe_set(s,n[1],48 + (c % 10 | 0) | 0);
                   break;
                  case 2:
                   caml_bytes_unsafe_set(s,n[1],92);
                   n[1]++;
                   caml_bytes_unsafe_set(s,n[1],c);
                   break;
                  case 3:caml_bytes_unsafe_set(s,n[1],c);break
                  }
                n[1]++;
                var _oZ_=i + 1 | 0;
                if(_oY_ !== i){var i=_oZ_;continue}
                break}}
            var _o4_=s}
          var str$0=caml_string_of_bytes(_o4_)}
        var l=caml_ml_string_length(str$0),res=make(l + 2 | 0,34);
        caml_blit_string(str$0,0,res,1,l);
        return caml_string_of_bytes(res)}}
    function format_of_fconv(fconv,prec)
     {var prec$0=abs(prec);
      if(opt)var sth=opt[1],cF=sth;else var cF=70;
      switch(fconv[2])
       {case 0:var symb=102;break;
        case 1:var symb=101;break;
        case 2:var symb=69;break;
        case 3:var symb=103;break;
        case 4:var symb=71;break;
        case 5:var symb=cF;break;
        case 6:var symb=104;break;
        case 7:var symb=72;break;
        default:var symb=70}
      var buf=buffer_create(16);
      buffer_add_char(buf,37);
      switch(fconv[1])
       {case 0:break;
        case 1:buffer_add_char(buf,43);break;
        default:buffer_add_char(buf,32)}
      if(8 <= fconv[2])buffer_add_char(buf,35);
      buffer_add_char(buf,46);
      buffer_add_string(buf,caml_string_of_jsbytes("" + prec$0));
      buffer_add_char(buf,symb);
      return buffer_contents(buf)}
    function transform_int_alt(iconv,s)
     {if(13 <= iconv)
       {var n=[0,0],_oQ_=caml_ml_string_length(s) - 1 | 0,_oP_=0;
        if(! (_oQ_ < 0))
         {var i$0=_oP_;
          for(;;)
           {var match=caml_string_unsafe_get(s,i$0),switcher$0=match - 48 | 0;
            if(! (9 < switcher$0 >>> 0))n[1]++;
            var _oU_=i$0 + 1 | 0;
            if(_oQ_ !== i$0){var i$0=_oU_;continue}
            break}}
        var
         digits=n[1],
         buf=
          caml_create_bytes
           (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
         pos=[0,0],
         put=function(c){caml_bytes_set(buf,pos[1],c);pos[1]++;return 0},
         left=[0,((digits - 1 | 0) % 3 | 0) + 1 | 0],
         _oS_=caml_ml_string_length(s) - 1 | 0,
         _oR_=0;
        if(! (_oS_ < 0))
         {var i=_oR_;
          for(;;)
           {var c=caml_string_unsafe_get(s,i),switcher=c - 48 | 0;
            if(9 < switcher >>> 0)
             put(c);
            else
             {if(0 === left[1]){put(95);left[1] = 3}left[1] += -1;put(c)}
            var _oT_=i + 1 | 0;
            if(_oS_ !== i){var i=_oT_;continue}
            break}}
        return caml_string_of_bytes(buf)}
      return s}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 1:var _oO_=_aw_;break;
        case 2:var _oO_=_ax_;break;
        case 4:var _oO_=_az_;break;
        case 5:var _oO_=_aA_;break;
        case 6:var _oO_=_aB_;break;
        case 7:var _oO_=_aC_;break;
        case 8:var _oO_=_aD_;break;
        case 9:var _oO_=_aE_;break;
        case 10:var _oO_=_aF_;break;
        case 11:var _oO_=_aG_;break;
        case 0:
        case 13:var _oO_=_av_;break;
        case 3:
        case 14:var _oO_=_ay_;break;
        default:var _oO_=_aH_}
      return transform_int_alt(iconv,caml_format_int(_oO_,n))}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 1:var _oN_=_aW_;break;
        case 2:var _oN_=_aX_;break;
        case 4:var _oN_=_aZ_;break;
        case 5:var _oN_=_a0_;break;
        case 6:var _oN_=_a1_;break;
        case 7:var _oN_=_a2_;break;
        case 8:var _oN_=_a3_;break;
        case 9:var _oN_=_a4_;break;
        case 10:var _oN_=_a5_;break;
        case 11:var _oN_=_a6_;break;
        case 0:
        case 13:var _oN_=_aV_;break;
        case 3:
        case 14:var _oN_=_aY_;break;
        default:var _oN_=_a7_}
      return transform_int_alt(iconv,caml_format_int(_oN_,n))}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 1:var _oM_=_a9_;break;
        case 2:var _oM_=_a__;break;
        case 4:var _oM_=_ba_;break;
        case 5:var _oM_=_bb_;break;
        case 6:var _oM_=_bc_;break;
        case 7:var _oM_=_bd_;break;
        case 8:var _oM_=_be_;break;
        case 9:var _oM_=_bf_;break;
        case 10:var _oM_=_bg_;break;
        case 11:var _oM_=_bh_;break;
        case 0:
        case 13:var _oM_=_a8_;break;
        case 3:
        case 14:var _oM_=_a$_;break;
        default:var _oM_=_bi_}
      return transform_int_alt(iconv,caml_format_int(_oM_,n))}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 1:var _oL_=_aJ_;break;
        case 2:var _oL_=_aK_;break;
        case 4:var _oL_=_aM_;break;
        case 5:var _oL_=_aN_;break;
        case 6:var _oL_=_aO_;break;
        case 7:var _oL_=_aP_;break;
        case 8:var _oL_=_aQ_;break;
        case 9:var _oL_=_aR_;break;
        case 10:var _oL_=_aS_;break;
        case 11:var _oL_=_aT_;break;
        case 0:
        case 13:var _oL_=_aI_;break;
        case 3:
        case 14:var _oL_=_aL_;break;
        default:var _oL_=_aU_}
      return transform_int_alt(iconv,caml_int64_format(_oL_,n))}
    function convert_float(fconv,prec,x)
     {function hex(param)
       {switch(fconv[1])
         {case 0:var sign=45;break;
          case 1:var sign=43;break;
          default:var sign=32}
        return caml_hexstring_of_float(x,prec,sign)}
      function caml_special_val(str)
       {var match=caml_classify_float(x);
        return 3 === match?x < 0.?_bk_:_bl_:4 <= match?_bm_:str}
      switch(fconv[2])
       {case 5:
         var
          str=caml_format_float(format_of_fconv(fconv,prec),x),
          len=caml_ml_string_length(str),
          i$0=0;
         for(;;)
          {if(i$0 === len)
            var _oJ_=0;
           else
            {var
              match=caml_string_get(str,i$0),
              _oI_=match - 46 | 0,
              switch$0=0;
             if(23 < _oI_ >>> 0)
              {if(55 === _oI_)switch$0 = 1}
             else
              if(21 < (_oI_ - 1 | 0) >>> 0)switch$0 = 1;
             if(! switch$0){var i$1=i$0 + 1 | 0,i$0=i$1;continue}
             var _oJ_=1}
           var _oK_=_oJ_?str:symbol(str,_bj_);
           return caml_special_val(_oK_)}
        case 6:return hex(0);
        case 7:
         var s$0=hex(0),s=caml_bytes_of_string(s$0),l=caml_ml_bytes_length(s);
         if(0 === l)
          var _oH_=s;
         else
          {var r=caml_create_bytes(l),_oE_=l - 1 | 0,_oD_=0;
           if(! (_oE_ < 0))
            {var i=_oD_;
             for(;;)
              {var c=caml_bytes_unsafe_get(s,i),switch$1=0;
               if(97 <= c && ! (122 < c)){var _oF_=c - 32 | 0;switch$1 = 1}
               if(! switch$1)var _oF_=c;
               caml_bytes_unsafe_set(r,i,_oF_);
               var _oG_=i + 1 | 0;
               if(_oE_ !== i){var i=_oG_;continue}
               break}}
           var _oH_=r}
         return caml_string_of_bytes(_oH_);
        case 8:return caml_special_val(hex(0));
        default:return caml_format_float(format_of_fconv(fconv,prec),x)}}
    function make_int_padding_precision(k,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return match
                 ?function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _oA_=pad[2],_oB_=pad[1];
          if(typeof match === "number")
           return match
                   ?function(p,x)
                     {var
                       str=
                        fix_padding
                         (_oB_,_oA_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,[4,acc,str],fmt)}
                   :function(x)
                     {var str=fix_padding(_oB_,_oA_,caml_call2(trans,iconv,x));
                      return make_printf(k,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_oB_,_oA_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,[4,acc,str],fmt)}}
        var _oC_=pad[1];
        if(typeof match === "number")
         return match
                 ?function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_oC_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(w,x)
                   {var str=fix_padding(_oC_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_oC_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,[4,acc,str],fmt)}}}
    function make_padding(k,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,new_acc,fmt)}}}
    function make_printf$0(counter,k,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var switch$0=0;
             if(40 <= c)
              if(92 === c)
               var str=_f_;
              else
               if(127 <= c)switch$0 = 1;else switch$0 = 2;
             else
              if(32 <= c)
               if(39 <= c)var str=_g_;else switch$0 = 2;
              else
               if(14 <= c)
                switch$0 = 1;
               else
                switch(c)
                 {case 8:var str=_h_;break;
                  case 9:var str=_i_;break;
                  case 10:var str=_j_;break;
                  case 13:var str=_k_;break;
                  default:switch$0 = 1}
             switch(switch$0)
              {case 1:
                var s=caml_create_bytes(4);
                caml_bytes_unsafe_set(s,0,92);
                caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
                caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
                caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
                var str=caml_string_of_bytes(s);
                break;
               case 2:
                var s$0=caml_create_bytes(1);
                caml_bytes_unsafe_set(s$0,0,c);
                var str=caml_string_of_bytes(s$0);
                break
               }
             var l=caml_ml_string_length(str),res=make(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,caml_string_of_bytes(res)];
             return make_printf(k$0,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding(k$0,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return prec$3
                      ?function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(x)
                        {var
                          str=
                           convert_float(fconv,default_float_precision(fconv),x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _ow_=pad$5[2],_ox_=pad$5[1];
               if(typeof prec$3 === "number")
                return prec$3
                        ?function(p,x)
                          {var str=fix_padding(_ox_,_ow_,convert_float(fconv,p,x));
                           return make_printf(k$0,[4,acc$0,str],rest$7)}
                        :function(x)
                          {var
                            str=convert_float(fconv,default_float_precision(fconv),x),
                            str$0=fix_padding(_ox_,_ow_,str);
                           return make_printf(k$0,[4,acc$0,str$0],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_ox_,_ow_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,[4,acc$0,str],rest$7)}}
             var _oy_=pad$5[1];
             if(typeof prec$3 === "number")
              return prec$3
                      ?function(w,p,x)
                        {var str=fix_padding(_oy_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision(fconv),x),
                          str$0=fix_padding(_oy_,w,str);
                         return make_printf(k$0,[4,acc$0,str$0],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_oy_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var rest$9=fmt$0[3],sub_fmtty=fmt$0[2],buf=buffer_create(16);
           bprint_fmtty(buf,sub_fmtty);
           var ty=buffer_contents(buf);
           return function(str){return make_printf(k$0,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var
              fmt$0=param[1],
              fmtty$0=erase_rel(symm(fmtty)),
              _oz_=type_format_gen(fmt$0,fmtty$0);
             if(typeof _oz_[2] === "number")
              {var fmt=_oz_[1];
               return make_printf(k$0,acc$0,concat_fmt(fmt,rest$10))}
             throw Type_mismatch};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _ou_=fmt$0[1];
           if(0 === _ou_[0])
            {var
              rest$13=fmt$0[2],
              match=_ou_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(kacc)
                  {return make_printf(k,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_ou_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(kacc){return make_printf(k,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_bn_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,_bo_];
           return function(param){return make_printf(k$0,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(_bp_,n)];
             return make_printf(k$0,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return make_invalid_arg(counter$1,k$0,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,acc$0,rest$18]);
              case 1:
               if(counter < 50)
                {var counter$2=counter + 1 | 0;
                 return make_invalid_arg(counter$2,k$0,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,acc$0,rest$18]);
              case 2:throw [0,Assert_failure,_bq_];
              default:
               if(counter < 50)
                {var counter$3=counter + 1 | 0;
                 return make_invalid_arg(counter$3,k$0,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,acc$0,rest$18])}
           else
            switch(ign[0])
             {case 0:
               if(counter < 50)
                {var counter$4=counter + 1 | 0;
                 return make_invalid_arg(counter$4,k$0,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,acc$0,rest$18]);
              case 1:
               if(counter < 50)
                {var counter$5=counter + 1 | 0;
                 return make_invalid_arg(counter$5,k$0,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,acc$0,rest$18]);
              case 2:
               if(counter < 50)
                {var counter$6=counter + 1 | 0;
                 return make_invalid_arg(counter$6,k$0,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,acc$0,rest$18]);
              case 3:
               if(counter < 50)
                {var counter$7=counter + 1 | 0;
                 return make_invalid_arg(counter$7,k$0,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,acc$0,rest$18]);
              case 4:
               if(counter < 50)
                {var counter$8=counter + 1 | 0;
                 return make_invalid_arg(counter$8,k$0,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,acc$0,rest$18]);
              case 5:
               if(counter < 50)
                {var counter$9=counter + 1 | 0;
                 return make_invalid_arg(counter$9,k$0,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,acc$0,rest$18]);
              case 6:
               if(counter < 50)
                {var counter$10=counter + 1 | 0;
                 return make_invalid_arg(counter$10,k$0,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,acc$0,rest$18]);
              case 7:
               if(counter < 50)
                {var counter$11=counter + 1 | 0;
                 return make_invalid_arg(counter$11,k$0,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,acc$0,rest$18]);
              case 8:
               if(counter < 50)
                {var counter$12=counter + 1 | 0;
                 return make_invalid_arg(counter$12,k$0,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,acc$0,rest$18]);
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$15=counter + 1 | 0;
                 return make_from_fmtty$0
                         (counter$15,k$0,acc$0,fmtty$0,rest$18)}
               return caml_trampoline_return
                       (make_from_fmtty$0,[0,k$0,acc$0,fmtty$0,rest$18]);
              case 10:
               if(counter < 50)
                {var counter$13=counter + 1 | 0;
                 return make_invalid_arg(counter$13,k$0,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,acc$0,rest$18]);
              default:
               if(counter < 50)
                {var counter$14=counter + 1 | 0;
                 return make_invalid_arg(counter$14,k$0,acc$0,rest$18)}
               return caml_trampoline_return
                       (make_invalid_arg,[0,k$0,acc$0,rest$18])}
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _ov_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,acc$0,rest$19,arity,_ov_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,acc$0,rest$19,arity,_ov_])}}
    function make_from_fmtty$0(counter,k,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_ot_)
           {return make_from_fmtty(k,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_br_];
         default:throw [0,Assert_failure,_bs_]}}
    function make_invalid_arg(counter,k,acc,fmt)
     {var _os_=[8,acc,_bt_];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_os_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,_os_,fmt])}
    function make_custom$0(counter,k,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,acc,rest,arity$0,caml_call1(f,x))}}
      var _or_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_or_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,_or_,rest])}
    function make_printf(k,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,acc,fmt))}
    function make_from_fmtty(k,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,acc,fmtty,fmt))}
    function make_custom(k,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,acc,rest,arity,f))}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _op_=acc$0[2],_oq_=acc$0[1];
           if(0 === _op_[0])
            {var acc$1=_op_[1];
             bufput_acc(b,_oq_);
             add_string(b,_bu_);
             var acc$0=acc$1;
             continue}
           var acc$2=_op_[1];
           bufput_acc(b,_oq_);
           add_string(b,_bv_);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _on_=acc$0[2],_oo_=acc$0[1];
           if(0 === _on_[0])
            {var acc$1=_on_[1];
             strput_acc(b,_oo_);
             add_string(b,_bw_);
             var acc$0=acc$1;
             continue}
           var acc$2=_on_[1];
           strput_acc(b,_oo_);
           add_string(b,_bx_);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function open_box_of_string(str)
     {if(caml_string_equal(str,_by_))return _bz_;
      var len=caml_ml_string_length(str);
      function invalid_box(param$0)
       {var fmt=param[1],buf=create$0(256);
        function k(acc){strput_acc(buf,acc);return failwith(contents(buf))}
        return caml_call1(make_printf(k,0,fmt),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match && 32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switch$0=0;
          if(48 <= match)
           {if(! (58 <= match))switch$0 = 1}
          else
           if(45 === match)switch$0 = 1;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _ol_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_ol_}
       catch(_om_)
        {_om_ = caml_wrap_exception(_om_);
         if(_om_[1] !== Failure)throw _om_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      var switch$0=0;
      if
       (caml_string_notequal(box_name,_bA_)
        &&
        caml_string_notequal(box_name,_bB_))
       var
        box_type=
         caml_string_notequal(box_name,_bC_)
          ?caml_string_notequal(box_name,_bD_)
            ?caml_string_notequal(box_name,_bE_)
              ?caml_string_notequal(box_name,_bF_)?invalid_box(0):1
              :2
            :3
          :0;
      else
       switch$0 = 1;
      if(switch$0)var box_type=4;
      return [0,indent,box_type]}
    function bprintf(b,fmt$0)
     {var fmt=fmt$0[1],_ok_=0;
      return make_printf(function(acc){bufput_acc(b,acc);return 0},_ok_,fmt)}
    var printers=[0,0];
    function register_printer(fn){printers[1] = [0,fn,printers[1]];return 0}
    try
     {var _kl_=caml_sys_getenv(_kk_),params=_kl_}
    catch(_oi_)
     {_oi_ = caml_wrap_exception(_oi_);
      if(_oi_ !== Not_found)throw _oi_;
      try
       {var _kj_=caml_sys_getenv(_ki_),_bH_=_kj_}
      catch(_oj_)
       {_oj_ = caml_wrap_exception(_oj_);
        if(_oj_ !== Not_found)throw _oj_;
        var _bH_=_bG_}
      var params=_bH_}
    contains(params,82);
    function id(x){return x}
    var String_tag=[248,_bI_,caml_fresh_oo_id(0)],size=0,unknown=-1;
    function pp_enqueue(state,token)
     {state[13] = state[13] + token[3] | 0;return add(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function format_pp_text(state,size,text)
     {state[9] = state[9] - size | 0;
      pp_output_string(state,text);
      state[11] = 0;
      return 0}
    function format_string(state,s)
     {var _oh_=caml_string_notequal(s,_bJ_);
      return _oh_?format_pp_text(state,caml_ml_string_length(s),s):_oh_}
    function break_new_line(state,param,width)
     {var after=param[3],offset=param[2],before=param[1];
      format_string(state,before);
      pp_output_newline(state);
      state[11] = 1;
      var
       y=(state[6] - width | 0) + offset | 0,
       _og_=state[8],
       real_indent=caml_lessequal(_og_,y)?_og_:y;
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      caml_call1(state[21],state[10]);
      return format_string(state,after)}
    function break_line(state,width){return break_new_line(state,_bK_,width)}
    function break_same_line(state,param)
     {var after=param[3],width=param[2],before=param[1];
      format_string(state,before);
      state[9] = state[9] - width | 0;
      caml_call1(state[20],width);
      return format_string(state,after)}
    function advance_left(state)
     {for(;;)
       {var _n8_=state[28][2];
        if(_n8_)var content=_n8_[1],match$12=[0,content];else var match$12=0;
        if(match$12)
         {var
           match$13=match$12[1],
           size$0=match$13[1],
           length$0=match$13[3],
           token=match$13[2],
           pending_count=state[13] - state[12] | 0,
           _od_=0 <= size$0?1:0,
           _oe_=_od_ || (state[9] <= pending_count?1:0);
          if(_oe_)
           {var _of_=state[28],_n9_=_of_[2];
            if(_n9_)
             {if(_n9_[2])
               {var next=_n9_[2];_of_[1] = _of_[1] - 1 | 0;_of_[2] = next}
              else
               clear$0(_of_);
              var size$1=0 <= size$0?size$0:pp_infinity;
              if(typeof token === "number")
               switch(token)
                {case 0:
                  var match$3=top_opt(state[3]);
                  if(match$3)
                   {var
                     match$4=match$3[1],
                     tabs=match$4[1],
                     add_tab=
                      function(n,ls)
                       {if(ls)
                         {var l=ls[2],x=ls[1];
                          return caml_lessthan(n,x)?[0,n,ls]:[0,x,add_tab(n,l)]}
                        return [0,n,0]};
                    tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1])}
                  break;
                 case 1:pop_opt(state[2]);break;
                 case 2:pop_opt(state[3]);break;
                 case 3:
                  var match$5=top_opt(state[2]);
                  if(match$5)
                   {var match$6=match$5[1],width$0=match$6[2];
                    break_line(state,width$0)}
                  else
                   pp_output_newline(state);
                  break;
                 case 4:
                  if(state[10] !== (state[6] - state[9] | 0))
                   {var _oa_=state[28],_n__=_oa_[2];
                    if(_n__)
                     {var _n$_=_n__[1];
                      if(_n__[2])
                       {var next$0=_n__[2];
                        _oa_[1] = _oa_[1] - 1 | 0;
                        _oa_[2] = next$0;
                        var match$1=[0,_n$_]}
                      else
                       {clear$0(_oa_);var match$1=[0,_n$_]}}
                    else
                     var match$1=0;
                    if(match$1)
                     {var match$2=match$1[1],size=match$2[1],length=match$2[3];
                      state[12] = state[12] - length | 0;
                      state[9] = state[9] + size | 0}}
                  break;
                 default:
                  var match$7=pop_opt(state[5]);
                  if(match$7)
                   {var
                     tag_name=match$7[1],
                     marker=caml_call1(state[25],tag_name);
                    pp_output_string(state,marker)}}
              else
               switch(token[0])
                {case 0:var s=token[1];format_pp_text(state,size$1,s);break;
                 case 1:
                  var
                   breaks=token[2],
                   fits=token[1],
                   off=breaks[2],
                   before=breaks[1],
                   match$8=top_opt(state[2]);
                  if(match$8)
                   {var
                     match$9=match$8[1],
                     width$1=match$9[2],
                     box_type$0=match$9[1];
                    switch(box_type$0)
                     {case 0:break_same_line(state,fits);break;
                      case 1:break_new_line(state,breaks,width$1);break;
                      case 2:break_new_line(state,breaks,width$1);break;
                      case 3:
                       if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                        break_new_line(state,breaks,width$1);
                       else
                        break_same_line(state,fits);
                       break;
                      case 4:
                       if(state[11])
                        break_same_line(state,fits);
                       else
                        if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                         break_new_line(state,breaks,width$1);
                        else
                         if(((state[6] - width$1 | 0) + off | 0) < state[10])
                          break_new_line(state,breaks,width$1);
                         else
                          break_same_line(state,fits);
                       break;
                      default:break_same_line(state,fits)}}
                  break;
                 case 2:
                  var
                   off$0=token[2],
                   n=token[1],
                   insertion_point=state[6] - state[9] | 0,
                   match$10=top_opt(state[3]);
                  if(match$10)
                   {var match$11=match$10[1],tabs$0=match$11[1],_ob_=tabs$0[1];
                    if(_ob_)
                     {var first=_ob_[1],param=tabs$0[1];
                      for(;;)
                       {if(param)
                         {var tail=param[2],head=param[1];
                          if(! (insertion_point <= head)){var param=tail;continue}
                          var _oc_=head}
                        else
                         var _oc_=first;
                        var tab=_oc_;
                        break}}
                    else
                     var tab=insertion_point;
                    var offset=tab - insertion_point | 0;
                    if(0 <= offset)
                     break_same_line(state,[0,_bM_,offset + n | 0,_bL_]);
                    else
                     break_new_line(state,[0,_bO_,tab + off$0 | 0,_bN_],state[6])}
                  break;
                 case 3:
                  var
                   ty=token[2],
                   off$1=token[1],
                   insertion_point$0=state[6] - state[9] | 0;
                  if(state[8] < insertion_point$0)
                   {var match=top_opt(state[2]);
                    if(match)
                     {var match$0=match[1],width=match$0[2],box_type=match$0[1];
                      if(state[9] < width)
                       {var switcher=box_type - 1 | 0;
                        if(! (3 < switcher >>> 0))break_line(state,width)}}
                    else
                     pp_output_newline(state)}
                  var
                   width$2=state[9] - off$1 | 0,
                   box_type$1=1 === ty?1:state[9] < size$1?ty:5;
                  push([0,box_type$1,width$2],state[2]);
                  break;
                 case 4:var tbox=token[1];push(tbox,state[3]);break;
                 default:
                  var
                   tag_name$0=token[1],
                   marker$0=caml_call1(state[24],tag_name$0);
                  pp_output_string(state,marker$0);
                  push(tag_name$0,state[5])}
              state[12] = length$0 + state[12] | 0;
              continue}
            throw Empty}
          return _oe_}
        return 0}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    function initialize_scan_stack(stack)
     {clear(stack);
      var queue_elem=[0,unknown,_bP_,0];
      return push([0,-1,queue_elem],stack)}
    function set_size(state,ty)
     {var match=top_opt(state[1]);
      if(match)
       {var
         match$0=match[1],
         queue_elem=match$0[2],
         left_total=match$0[1],
         _n5_=queue_elem[1];
        if(left_total < state[12])return initialize_scan_stack(state[1]);
        var _n6_=queue_elem[2];
        if(typeof _n6_ !== "number")
         switch(_n6_[0])
          {case 3:
            var _n7_=1 - ty;
            return _n7_
                    ?(queue_elem[1] = state[13] + _n5_ | 0,pop_opt(state[1]),0)
                    :_n7_;
           case 1:
           case 2:
            return ty
                    ?(queue_elem[1] = state[13] + _n5_ | 0,pop_opt(state[1]),0)
                    :ty
           }
        return 0}
      return 0}
    function scan_push(state,b,token)
     {pp_enqueue(state,token);
      if(b)set_size(state,1);
      var elem=[0,state[13],token];
      return push(elem,state[1])}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var size=- state[13] | 0,elem=[0,size,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _n3_=state[14] === state[15]?1:0;
      if(_n3_)
       {var _n4_=state[16];
        return enqueue_string_as(state,caml_ml_string_length(_n4_),_n4_)}
      return _n3_}
    function pp_close_box(state,param)
     {var _n1_=1 < state[14]?1:0;
      if(_n1_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,size,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _n2_=0}
      else
       var _n2_=_n1_;
      return _n2_}
    function pp_open_stag(state,tag_name)
     {if(state[22]){push(tag_name,state[4]);caml_call1(state[26],tag_name)}
      var _n0_=state[23];
      if(_n0_)
       {var token=[5,tag_name];return pp_enqueue(state,[0,size,token,0])}
      return _n0_}
    function pp_close_tag(state,param)
     {if(state[23])pp_enqueue(state,[0,size,5,0]);
      var _nY_=state[22];
      if(_nY_)
       {var match=pop_opt(state[4]);
        if(match){var tag_name=match[1];return caml_call1(state[27],tag_name)}
        var _nZ_=0}
      else
       var _nZ_=_nY_;
      return _nZ_}
    function pp_flush_queue(state,b)
     {var param=state[4][1];
      for(;;)
       {if(param){var l=param[2];pp_close_tag(state,0);var param=l;continue}
        for(;;)
         {if(1 < state[14]){pp_close_box(state,0);continue}
          state[13] = pp_infinity;
          advance_left(state);
          if(b)pp_output_newline(state);
          state[12] = 1;
          state[13] = 1;
          clear$0(state[28]);
          initialize_scan_stack(state[1]);
          clear(state[2]);
          clear(state[3]);
          clear(state[4]);
          clear(state[5]);
          state[10] = 0;
          state[14] = 0;
          state[9] = state[6];
          return pp_open_box_gen(state,0,3)}}}
    function pp_print_as_size(state,size,s)
     {var _nX_=state[14] < state[15]?1:0;
      return _nX_?enqueue_string_as(state,size,s):_nX_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_char(state,c){return pp_print_as(state,1,make$0(1,c))}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    var blank_line=make$0(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _nW_=0 < n$0?1:0;
        if(_nW_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _nW_}}
    function default_pp_mark_open_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return symbol(_bW_,symbol(s,_bV_))}
      return _bX_}
    function default_pp_mark_close_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return symbol(_bZ_,symbol(s,_bY_))}
      return _b0_}
    function default_pp_print_open_tag(_nV_){return 0}
    function default_pp_print_close_tag(_nU_){return 0}
    function make_formatter(output,flush)
     {function j(_nT_){return 0}
      function i(_nS_){return 0}
      function h(_nR_){return 0}
      var pp_queue=[0,0,0,0],sys_tok=[0,unknown,_b1_,0];
      add(sys_tok,pp_queue);
      var scan_stack=create(0);
      initialize_scan_stack(scan_stack);
      push([0,1,sys_tok],scan_stack);
      var
       _nL_=create(0),
       _nM_=create(0),
       _nN_=create(0),
       ppf=
        [0,
         scan_stack,
         create(0),
         _nN_,
         _nM_,
         _nL_,
         78,
         10,
         68,
         78,
         0,
         1,
         1,
         1,
         1,
         max_int_float,
         _b2_,
         output,
         flush,
         h,
         i,
         j,
         0,
         0,
         default_pp_mark_open_tag,
         default_pp_mark_close_tag,
         default_pp_print_open_tag,
         default_pp_print_close_tag,
         pp_queue];
      ppf[19] = function(_nQ_){return caml_call3(ppf[17],_bU_,0,1)};
      ppf[20] = function(_nP_){return display_indent(ppf,_nP_)};
      ppf[21] = function(_nO_){return display_indent(ppf,_nO_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _nK_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(s,ofs,len)
                {if
                  (0
                   <=
                   ofs
                   &&
                   0
                   <=
                   len
                   &&
                   !
                   ((caml_ml_string_length(s) - len | 0) < ofs))
                  return caml_ml_output(oc,s,ofs,len);
                 return invalid_arg(_c_)},
               _nK_)}
    function formatter_of_buffer(b)
     {function _nF_(_nJ_){return 0}
      return make_formatter
              (function(s,offset,len)
                {var _nG_=offset < 0?1:0;
                 if(_nG_)
                  var _nH_=_nG_;
                 else
                  var
                   _nI_=len < 0?1:0,
                   _nH_=
                    _nI_
                    ||
                    ((caml_ml_string_length(s) - len | 0) < offset?1:0);
                 if(_nH_)invalid_arg(_G_);
                 var new_position=b[2] + len | 0;
                 if(b[3] < new_position)resize(b,len);
                 caml_blit_string(s,offset,b[1],b[2],len);
                 b[2] = new_position;
                 return 0},
               _nF_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$0(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(stdout),
     ppf=formatter_of_out_channel(stderr);
    formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);
      var s=contents(buf);
      buf[2] = 0;
      buf[1] = buf[4];
      buf[3] = caml_ml_bytes_length(buf[1]);
      return s}
    function compute_tag(output,tag_acc)
     {var b=create$0(16),ppf=formatter_of_buffer(b);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=b[2];
      if(2 <= len)
       {var len$0=len - 2 | 0,ofs=1;
        if(0 <= len$0 && ! ((b[2] - len$0 | 0) < 1))
         return sub_string(b[1],ofs,len$0);
        return invalid_arg(_C_)}
      return contents(b)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:
          var _nD_=ppf[14] < ppf[15]?1:0;
          return _nD_?enqueue_advance(ppf,[0,size,3,0]):_nD_;
         case 4:pp_flush_queue(ppf,1);return caml_call1(ppf[18],0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var
           offset=fmting_lit[3],
           width$0=fmting_lit[2],
           breaks=[0,_bR_,offset,_bQ_],
           fits=[0,_bT_,width$0,_bS_],
           after=fits[3],
           width=fits[2],
           before=fits[1],
           _nE_=ppf[14] < ppf[15]?1:0;
          if(_nE_)
           {var
             size$0=- ppf[13] | 0,
             token=[1,fits,breaks],
             length=
              (caml_ml_string_length(before) + width | 0)
              +
              caml_ml_string_length(after)
              |
              0,
             elem=[0,size$0,token,length];
            return scan_push(ppf,1,elem)}
          return _nE_;
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _nt_=acc[2],_nu_=acc[1];
          if(0 === _nt_[0])
           {var acc$0=_nt_[1];
            output_acc(ppf,_nu_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(output_acc,acc$0)])}
          var acc$1=_nt_[1];
          output_acc(ppf,_nu_);
          var
           match=open_box_of_string(compute_tag(output_acc,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _nv_=acc[1],switch$1=0;
          if(typeof _nv_ !== "number" && 0 === _nv_[0])
           {var _nw_=_nv_[2],switch$2=0;
            if(typeof _nw_ !== "number" && 1 === _nw_[0])
             {var s$0=acc[2],size=_nw_[2],p$1=_nv_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_nv_;switch$0 = 2}
          break;
         case 3:
          var _nx_=acc[1],switch$3=0;
          if(typeof _nx_ !== "number" && 0 === _nx_[0])
           {var _ny_=_nx_[2],switch$4=0;
            if(typeof _ny_ !== "number" && 1 === _ny_[0])
             {var c$0=acc[2],size$0=_ny_[2],p$3=_nx_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_nx_;switch$0 = 3}
          break;
         case 4:
          var _nz_=acc[1],switch$5=0;
          if(typeof _nz_ !== "number" && 0 === _nz_[0])
           {var _nA_=_nz_[2],switch$6=0;
            if(typeof _nA_ !== "number" && 1 === _nA_[0])
             {var s$0=acc[2],size=_nA_[2],p$1=_nz_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_nz_;switch$0 = 2}
          break;
         case 5:
          var _nB_=acc[1],switch$7=0;
          if(typeof _nB_ === "number" || ! (0 === _nB_[0]))
           switch$7 = 1;
          else
           {var _nC_=_nB_[2],switch$8=0;
            if(typeof _nC_ !== "number" && 1 === _nC_[0])
             {var c$0=acc[2],size$0=_nC_[2],p$3=_nB_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_nB_;switch$0 = 3}
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:output_acc(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _nh_=acc[2],_ni_=acc[1];
          if(0 === _nh_[0])
           {var acc$0=_nh_[1];
            strput_acc$0(ppf,_ni_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(strput_acc$0,acc$0)])}
          var acc$1=_nh_[1];
          strput_acc$0(ppf,_ni_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _nj_=acc[1],switch$1=0;
          if(typeof _nj_ !== "number" && 0 === _nj_[0])
           {var _nk_=_nj_[2],switch$2=0;
            if(typeof _nk_ !== "number" && 1 === _nk_[0])
             {var s$0=acc[2],size=_nk_[2],p$1=_nj_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_nj_;switch$0 = 2}
          break;
         case 3:
          var _nl_=acc[1],switch$3=0;
          if(typeof _nl_ !== "number" && 0 === _nl_[0])
           {var _nm_=_nl_[2],switch$4=0;
            if(typeof _nm_ !== "number" && 1 === _nm_[0])
             {var c$0=acc[2],size$0=_nm_[2],p$3=_nl_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_nl_;switch$0 = 3}
          break;
         case 4:
          var _nn_=acc[1],switch$5=0;
          if(typeof _nn_ !== "number" && 0 === _nn_[0])
           {var _no_=_nn_[2],switch$6=0;
            if(typeof _no_ !== "number" && 1 === _no_[0])
             {var s$0=acc[2],size=_no_[2],p$1=_nn_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_nn_;switch$0 = 2}
          break;
         case 5:
          var _np_=acc[1],switch$7=0;
          if(typeof _np_ === "number" || ! (0 === _np_[0]))
           switch$7 = 1;
          else
           {var _nq_=_np_[2],switch$8=0;
            if(typeof _nq_ !== "number" && 1 === _nq_[0])
             {var c$0=acc[2],size$0=_nq_[2],p$3=_np_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_np_;switch$0 = 3}
          break;
         case 6:
          var _nr_=acc[1];
          if(typeof _nr_ !== "number" && 0 === _nr_[0])
           {var _ns_=_nr_[2];
            if(typeof _ns_ !== "number" && 1 === _ns_[0])
             {var f$1=acc[2],size$1=_ns_[2],p$4=_nr_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_nr_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf(k,ppf,param)
     {var fmt=param[1],_ng_=0;
      return make_printf
              (function(acc){output_acc(ppf,acc);return caml_call1(k,ppf)},
               _ng_,
               fmt)}
    function fprintf(ppf)
     {function _nd_(_nf_){return 0}
      return function(_ne_){return kfprintf(_nd_,ppf,_ne_)}}
    function printf(fmt){return caml_call1(fprintf(std_formatter),fmt)}
    function kprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function sprintf(fmt){return kprintf(id,fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {output_acc(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function flush_standard_formatters(param)
     {pp_print_flush(std_formatter,0);return pp_print_flush(ppf,0)}
    at_exit(flush_standard_formatters);
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var initial_object_size=2;
    function public_method_label(s)
     {var accu=[0,0],_na_=caml_ml_string_length(s) - 1 | 0,_m$_=0;
      if(! (_na_ < 0))
       {var i=_m$_;
        for(;;)
         {var _nb_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _nb_ | 0;
          var _nc_=i + 1 | 0;
          if(_na_ !== i){var i=_nc_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    var
     compare=caml_string_compare,
     Vars=_z_([0,compare]),
     compare$0=caml_string_compare,
     Meths=_z_([0,compare$0]),
     compare$1=caml_int_compare,
     Labs=_z_([0,compare$1]),
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _m5_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _m5_;
      var _m7_=len - 1 | 0,_m6_=0;
      if(! (_m7_ < 0))
       {var i=_m6_;
        for(;;)
         {var
           _m9_=(i * 2 | 0) + 3 | 0,
           _m8_=caml_check_bound(pub_labels,i)[1 + i];
          caml_check_bound(methods,_m9_)[1 + _m9_] = _m8_;
          var _m__=i + 1 | 0;
          if(_m7_ !== i){var i=_m__;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$0(array,new_size)
     {var len=array[2].length - 1,_m2_=len < new_size?1:0;
      if(_m2_)
       {var a2=caml_make_vect(new_size,dummy_met),_m3_=array[2],switch$0=0;
        if
         (0
          <=
          len
          &&
          !
          ((_m3_.length - 1 - len | 0) < 0)
          &&
          !
          ((a2.length - 1 - len | 0) < 0))
         {caml_array_blit(_m3_,0,a2,0,len);switch$0 = 1}
        if(! switch$0)invalid_arg(_q_);
        array[2] = a2;
        var _m4_=0}
      else
       var _m4_=_m2_;
      return _m4_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$0(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _m0_=caml_call2(Meths[27],name,table[3]);return _m0_}
      catch(_m1_)
       {_m1_ = caml_wrap_exception(_m1_);
        if(_m1_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _m1_}}
    function get_method_labels(table,names)
     {return map$1(function(_mZ_){return get_method_label(table,_mZ_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[27],label,table[4])
              ?(resize$0(table,label + 1 | 0),
                caml_check_bound(table[2],label)[1 + label]
                =
                element,
                0)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _mX_=caml_call2(Vars[27],name,table[7]);return _mX_}
      catch(_mY_)
       {_mY_ = caml_wrap_exception(_mY_);
        if(_mY_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,_b3_))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _mY_}}
    function create_table(public_methods)
     {if(0 === public_methods)return new_table([0]);
      var
       tags=map$1(public_method_label,public_methods),
       table=new_table(tags),
       _mV_=public_methods.length - 1 - 1 | 0,
       _mU_=0;
      if(! (_mV_ < 0))
       {var i=_mU_;
        for(;;)
         {var met=public_methods[1 + i],lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          var _mW_=i + 1 | 0;
          if(_mV_ !== i){var i=_mW_;continue}
          break}}
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      var l1=table[8],l2=0;
      for(;;)
       {if(l1){var l1$0=l1[2],a=l1[1],l2$0=[0,a,l2],l1=l1$0,l2=l2$0;continue}
        table[8] = l2;
        return resize$0
                (table,
                 3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function new_cache(table)
     {var n=new_method(table),switch$0=0;
      if
       (0
        !==
        (n % 2 | 0)
        &&
        !
        ((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n))
       {var n$0=new_method(table);switch$0 = 1}
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[1 + n$0] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _mO_=i[1],
           label=caml_check_bound(methods,_mO_)[1 + _mO_],
           next=
            function(param)
             {i[1]++;
              var _mT_=i[1];
              return caml_check_bound(methods,_mT_)[1 + _mT_]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[1 + n]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[1 + e][1 + n]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][1 + n],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[1 + n] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[1 + n])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[1 + e][1 + n])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][1 + n],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[1 + n])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[1 + e][1 + n])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][1 + n],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[1 + n],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[1 + e][1 + n],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][1 + n],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + m])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + e][1 + m])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _mR_=caml_call1(obj[1][1 + m],obj);
                     return caml_call2(obj[1][1 + n],obj,_mR_)}}
                 (n$15,m$1);
              break;
             case 20:
              var
               m$2=next(0),
               x$9=next(0),
               c=new_cache(table),
               clo$0=
                function(m,x,c)
                  {return function(obj)
                    {return caml_call2(caml_get_public_method(x,m,0),x,c)}}
                 (m$2,x$9,c);
              break;
             case 21:
              var
               m$3=next(0),
               n$16=next(0),
               c$0=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _mQ_=obj[1 + n];
                     return caml_call2(caml_get_public_method(_mQ_,m,0),_mQ_,c)}}
                 (m$3,n$16,c$0);
              break;
             case 22:
              var
               m$4=next(0),
               e$4=next(0),
               n$17=next(0),
               c$1=new_cache(table),
               clo$0=
                function(m,e,n,c)
                  {return function(obj)
                    {var _mP_=obj[1 + e][1 + n];
                     return caml_call2(caml_get_public_method(_mP_,m,0),_mP_,c)}}
                 (m$4,e$4,n$17,c$1);
              break;
             default:
              var
               m$5=next(0),
               n$18=next(0),
               c$2=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _mS_=caml_call1(obj[1][1 + n],obj);
                     return caml_call2(caml_get_public_method(_mS_,m,0),_mS_,c)}}
                 (m$5,n$18,c$2)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    var global=joo_global_object,null$0=null,undefined$0=undefined;
    function to_option(x){return x == null$0?0:[0,x]}
    var
     object_constructor=global.Object,
     array_length=global.Array,
     date_ms=global.Date,
     Error=[248,_b4_,caml_fresh_oo_id(0)];
    register_exception(_b5_,[0,Error,{}]);
    (function(exn){throw exn});
    register_printer
     (function(param)
       {if(param[1] === Error)
         {var e=param[2];return [0,caml_string_of_jsstring(e.toString())]}
        return 0});
    register_printer
     (function(e)
       {return e instanceof array_length
                ?0
                :[0,caml_string_of_jsstring(e.toString())]});
    function export$0(field,x)
     {var field$0=caml_jsstring_of_string(field);
      return caml_js_export_var(0)[field$0] = x}
    var
     json=global.JSON,
     mlString_constr=dummy_string.constructor,
     mlInt64_constr=dummy_int64.constructor;
    function output_reviver(key,value)
     {return value instanceof mlString_constr
              ?caml_jsbytes_of_string(value)
              :value instanceof mlInt64_constr
                ?caml_js_from_array([0,255,value.lo,value.mi,value.hi])
                :value}
    function output(obj){return json.stringify(obj,output_reviver)}
    function make_alphabet(alphabet)
     {if(64 !== caml_ml_string_length(alphabet))invalid_arg(_b6_);
      if(contains(alphabet,61))invalid_arg(_b7_);
      function f(i){return caml_string_get(alphabet,i)}
      var l=caml_ml_string_length(alphabet);
      if(0 === l)
       var emap=[0];
      else
       if(0 <= l)
        {var res=caml_make_vect(l,f(0)),_mM_=l - 1 | 0,_mL_=1;
         if(! (_mM_ < 1))
          {var i$0=_mL_;
           for(;;)
            {res[1 + i$0] = f(i$0);
             var _mN_=i$0 + 1 | 0;
             if(_mM_ !== i$0){var i$0=_mN_;continue}
             break}}
         var emap=res}
       else
        var emap=invalid_arg(_p_);
      var
       dmap=caml_make_vect(256,-1),
       _mJ_=caml_ml_string_length(alphabet) - 1 | 0,
       _mI_=0;
      if(! (_mJ_ < 0))
       {var i=_mI_;
        for(;;)
         {var chr=caml_string_unsafe_get(alphabet,i);
          caml_check_bound(dmap,chr)[1 + chr] = i;
          var _mK_=i + 1 | 0;
          if(_mJ_ !== i){var i=_mK_;continue}
          break}}
      return [0,emap,dmap]}
    make_alphabet(_b8_);
    make_alphabet(_b9_);
    caml_fresh_oo_id(0);
    caml_fresh_oo_id(0);
    function pp_t(ppf,t)
     {var _mF_=caml_ba_dim_1(t[1]),_mG_=t[3],_mH_=t[2];
      return caml_call4(fprintf(ppf),_b__,_mH_,_mG_,_mF_)}
    function string_t(ppf,str)
     {return caml_call2(fprintf(ppf),_b$_,caml_ml_string_length(str))}
    function err(fmt)
     {var b=create$0(20),ppf=formatter_of_buffer(b);
      function k(ppf){pp_print_flush(ppf,0);return invalid_arg(contents(b))}
      return kfprintf(k,ppf,fmt)}
    function create_unsafe(len)
     {var buffer=caml_ba_create(12,0,[0,len]);return [0,buffer,0,len]}
    create_unsafe(0);
    function blitfun(src,srcoff,dst,dstoff,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        srcoff
        &&
        0
        <=
        dstoff
        &&
        !
        ((caml_ml_string_length(src) - srcoff | 0) < len))
       return (dst[3] - dstoff | 0) < len
               ?caml_call2
                 (caml_call4(err(_cc_),string_t,src,pp_t,dst),dstoff,len)
               :caml_blit_string_to_bigstring
                 (src,srcoff,dst[1],dst[2] + dstoff | 0,len);
      return caml_call2
              (caml_call4(err(_cb_),string_t,src,pp_t,dst),srcoff,len)}
    function of_string$0(allocator,off$0,len$1,buf)
     {if(off$0)var sth=off$0[1],off=sth;else var off=0;
      if(len$1)
       var len$0=len$1[1],buflen=len$0;
      else
       var buflen=caml_ml_string_length(buf);
      if(allocator)
       {var fn=allocator[1],t=caml_call1(fn,buflen);
        blitfun(buf,off,t,0,buflen);
        if(0 <= buflen)
         {var
           len=t[2] + buflen | 0,
           _mD_=0 <= len?1:0,
           _mE_=_mD_?len <= caml_ba_dim_1(t[1])?1:0:_mD_;
          if(_mE_)return [0,t[1],t[2],buflen]}
        return caml_call1(caml_call2(err(_ca_),pp_t,t),buflen)}
      var c=create_unsafe(buflen);
      blitfun(buf,off,c,0,buflen);
      return c}
    function hexdump_pp(fmt,t)
     {function before(fmt,param)
       {return 0 === param
                ?0
                :8 === param
                  ?caml_call1(fprintf(fmt),_cd_)
                  :caml_call1(fprintf(fmt),_ce_)}
      function after(fmt,param)
       {return 15 === param?caml_call1(fprintf(fmt),_cf_):0}
      pp_open_box_gen(fmt,0,1);
      var _mB_=t[3] - 1 | 0,_mA_=0;
      if(! (_mB_ < 0))
       {var i=_mA_;
        for(;;)
         {var column=i % 16 | 0,c=caml_ba_get_1(t[1],t[2] + i | 0);
          caml_call6(fprintf(fmt),_cg_,before,column,c,after,column);
          var _mC_=i + 1 | 0;
          if(_mB_ !== i){var i=_mC_;continue}
          break}}
      return pp_close_box(fmt,0)}
    caml_call1(printf(_ch_),hexdump_pp);
    function invalid_arg$0(fmt$0)
     {var fmt=fmt$0[1];
      function k(acc)
       {var buf=create$0(64);
        strput_acc(buf,acc);
        var str=contents(buf);
        throw [0,Invalid_argument,str]}
      return make_printf(k,0,fmt)}
    function to_bytes(hex)
     {var s=hex[2];
      if(caml_string_equal(s,_cj_))return empty_return;
      var
       n$0=caml_ml_string_length(s),
       buf=caml_create_bytes(n$0 / 2 | 0),
       i=0,
       j=1;
      for(;;)
       {if(! (n$0 <= i))
         {if(! (n$0 <= j))
           {var
             y=caml_string_get(s,j),
             x=caml_string_get(s,i),
             code=
              function(c)
               {if(65 <= c)
                 {if(97 <= c)
                   {if(! (103 <= c))return c - 87 | 0}
                  else
                   if(! (71 <= c))return c - 55 | 0}
                else
                 {var switcher=c - 48 | 0;
                  if(! (9 < switcher >>> 0))return c - 48 | 0}
                return caml_call1(invalid_arg$0(_ci_),c)},
             _my_=code(y),
             n=(code(x) << 4) + _my_ | 0,
             switch$0=0;
            if(0 <= n && ! (255 < n)){var _mz_=n;switch$0 = 1}
            if(! switch$0)var _mz_=invalid_arg(_e_);
            caml_bytes_set(buf,i / 2 | 0,_mz_);
            var j$0=j + 2 | 0,i$0=j + 1 | 0,i=i$0,j=j$0;
            continue}
          invalid_arg$0(_ck_)}
        return buf}}
    of_string$0(0,0,0,_cl_);
    function to_js(Codec,x){return caml_call1(Codec[1],x)}
    function of_js(Codec,x){return caml_call1(Codec[2],x)}
    var undefined$1=undefined;
    function comp(f,g,x){return caml_call1(f,caml_call1(g,x))}
    function codec_with(jsenc,jsdec)
     {function to_js(x){return caml_call1(jsenc,x)}
      function of_js(x){return caml_call1(jsdec,x)}
      return [0,to_js,of_js]}
    function fenc(param)
     {var x=param[3],codec=param[2],fname=param[1];
      return [0,fname,to_js(codec,x)]}
    var Field_codec_mismatch=[248,_cm_,caml_fresh_oo_id(0)];
    function find_field(fname,codec,fvalues)
     {var
       param$0=
        map$0(function(fv){var fname=fv[1];return [0,fname,fv]},fvalues),
       param=param$0;
      for(;;)
       {if(param)
         {var l=param[2],match=param[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,fname))
           {var x=b[3],c=b[2];
            if(c === codec)return of_js(codec,x);
            var c$0=b[2];
            throw [0,Field_codec_mismatch,c$0,codec]}
          var param=l;
          continue}
        throw Not_found}}
    function codec_record(param)
     {var projector=param[3],injector=param[2],fields=param[1];
      function jsenc(x)
       {return caml_js_object(of_list(map$0(fenc,caml_call1(projector,x))))}
      function jsdec(x)
       {return caml_call1
                (injector,
                 map$0
                  (function(param)
                    {var
                      codec=param[2],
                      fname=param[1],
                      js=x[caml_jsstring_of_string(fname)];
                     return [0,fname,codec,js]},
                   fields))}
      return codec_with(jsenc,jsdec)}
    function codec_variant(param)
     {var brancher=param[3],decoder=param[2],encoder=param[1];
      function jsdec(x)
       {var branch=caml_call1(brancher,x);
        return caml_call1(decoder,[0,branch,x])}
      return codec_with(encoder,jsdec)}
    function _cn_(_mx_){return _mx_}
    var
     field_codec_spell=codec_with(function(_mw_){return _mw_},_cn_),
     field_codec_bookhash=
      codec_with(caml_jsstring_of_string,caml_string_of_jsstring);
    function _co_(_mv_){return _mv_}
    var field_codec_amount=codec_with(function(_mu_){return _mu_},_co_);
    function _cp_(_mt_){return _mt_}
    function _cq_(_ms_){return _ms_ | 0}
    function _cr_(_mr_){return comp(_cq_,_cp_,_mr_)}
    function _cs_(_mq_){return _mq_}
    function _ct_(_mp_){return _mp_}
    var
     field_codec_minqueryinterval=
      codec_with(function(_mo_){return comp(_ct_,_cs_,_mo_)},_cr_),
     field_codec_succeeded=codec_with(caml_js_from_bool,caml_js_to_bool);
    function jsenc(x)
     {var
       s=to_string(x),
       len=caml_ml_string_length(s),
       buf=caml_create_bytes(len * 2 | 0),
       _mm_=len - 1 | 0,
       _ml_=0;
      if(! (_mm_ < 0))
       {var i=_ml_;
        for(;;)
         {caml_bytes_unsafe_set
           (buf,
            i * 2 | 0,
            caml_string_unsafe_get(hexa1,caml_string_unsafe_get(s,i)));
          caml_bytes_unsafe_set
           (buf,
            (i * 2 | 0) + 1 | 0,
            caml_string_unsafe_get(hexa2,caml_string_unsafe_get(s,i)));
          var _mn_=i + 1 | 0;
          if(_mm_ !== i){var i=_mn_;continue}
          break}}
      var encoded=to_string(buf);
      return caml_jsstring_of_string(encoded)}
    function jsdec(x){return to_bytes([0,3603131,caml_string_of_jsstring(x)])}
    var field_codec_signature=codec_with(jsenc,jsdec);
    function codec_list(codec)
     {function jsenc(x)
       {return caml_js_from_array
                (of_list(map$0(function(_mk_){return to_js(codec,_mk_)},x)))}
      function jsdec(x)
       {var _mi_=to_list(caml_js_to_array(x));
        return map$0(function(_mj_){return of_js(codec,_mj_)},_mi_)}
      return codec_with(jsenc,jsdec)}
    function codec_assoc(codec)
     {function jsenc(x)
       {return caml_js_object
                (of_list
                  (map$0
                    (function(param)
                      {var v=param[2],k=param[1];return [0,k,to_js(codec,v)]},
                     x)))}
      function jsdec(x)
       {var _mg_=to_list(caml_js_to_array(object_constructor.keys(x)));
        return map$0
                (function(key)
                  {var _mh_=of_js(codec,x[key]);
                   return [0,caml_string_of_jsstring(key),_mh_]},
                 _mg_)}
      return codec_with(jsenc,jsdec)}
    function codec_option(codec)
     {function jsenc(x)
       {if(x){var x$0=x[1];return to_js(codec,x$0)}return undefined$1}
      function jsdec(x)
       {var x$0=x === undefined$0?undefined$0:[0,of_js(codec,x)];
        return x$0 === undefined$0?0:x$0}
      return codec_with(jsenc,jsdec)}
    function symbol$0(_mf_,_me_){return caml_call1(_mf_,_me_)}
    function neg(param)
     {var _md_=param[1];
      if(caml_notequal(param[2],_cu_))
       {var ps=param[2];
        return [0,- (_md_ + 1 | 0) | 0,caml_int64_sub(ps_count_in_day,ps)]}
      return [0,- _md_ | 0,_cv_]}
    function add$0(param,_mc_)
     {var
       ps1=_mc_[2],
       d1=_mc_[1],
       ps0=param[2],
       d0=param[1],
       d=d0 + d1 | 0,
       ps=caml_int64_add(ps0,ps1),
       ps_clamp=caml_int64_mod(ps,ps_count_in_day),
       d$0=d + caml_int64_compare(ps,ps_clamp) | 0;
      return [0,d$0,ps_clamp]}
    function of_int_s(secs)
     {var
       d=abs(secs),
       s=
        [0,
         d / 86400 | 0,
         caml_int64_mul(caml_int64_of_int32(d % 86400 | 0),pow)];
      return 0 <= secs?s:neg(s)}
    var frac_div=_cx_.slice();
    function of_span(span)
     {var d=span[1];
      if(! (d < -719528) && ! (2932896 < d))return [0,span];
      return 0}
    function add_span(t,d){return of_span(add$0(t,d))}
    var mlen=_cy_.slice();
    function of_date_time(param)
     {var
       t=param[2],
       tz_offset_s=t[2],
       match$0=t[1],
       ss$0=match$0[3],
       mm$0=match$0[2],
       hh$0=match$0[1],
       date=param[1],
       d=date[3],
       m$0=date[2],
       y$0=date[1],
       _l1_=0 <= y$0?1:0;
      if(_l1_)
       {var _l2_=y$0 <= 9999?1:0;
        if(_l2_)
         {var _l3_=1 <= m$0?1:0;
          if(_l3_)
           {var _l4_=m$0 <= 12?1:0;
            if(_l4_)
             {var _l5_=1 <= d?1:0;
              if(_l5_)
               {var switch$0=0;
                if(2 === m$0)
                 {var _lX_=0 === (y$0 % 4 | 0)?1:0;
                  if(_lX_)
                   var
                    _lY_=0 !== (y$0 % 100 | 0)?1:0,
                    _lZ_=_lY_ || (0 === (y$0 % 400 | 0)?1:0);
                  else
                   var _lZ_=_lX_;
                  if(_lZ_){var _l6_=29;switch$0 = 1}}
                if(! switch$0)
                 var
                  _l0_=m$0 - 1 | 0,
                  _l6_=caml_check_bound(mlen,_l0_)[1 + _l0_];
                var _l7_=d <= _l6_?1:0}
              else
               var _l7_=_l5_}
            else
             var _l7_=_l4_}
          else
           var _l7_=_l3_}
        else
         var _l7_=_l2_}
      else
       var _l7_=_l1_;
      if(_l7_)
       {var match=t[1],ss=match[3],mm=match[2],hh=match[1],_l8_=0 <= hh?1:0;
        if(_l8_)
         {var _l9_=hh <= 23?1:0;
          if(_l9_)
           {var _l__=0 <= mm?1:0;
            if(_l__)
             {var _l$_=mm <= 59?1:0;
              if(_l$_)
               var _ma_=0 <= ss?1:0,_mb_=_ma_?ss <= 60?1:0:_ma_;
              else
               var _mb_=_l$_}
            else
             var _mb_=_l__}
          else
           var _mb_=_l9_}
        else
         var _mb_=_l8_;
        if(_mb_)
         {var
           day=date[3],
           month=date[2],
           year=date[1],
           a=(14 - month | 0) / 12 | 0,
           y=(year + 4800 | 0) - a | 0,
           m=(month + (12 * a | 0) | 0) - 3 | 0,
           d$0=
            ((((((day + (((153 * m | 0) + 2 | 0) / 5 | 0) | 0)
                 +
                 (365 * y | 0)
                 |
                 0)
                +
                (y / 4 | 0)
                |
                0)
               -
               (y / 100 | 0)
               |
               0)
              +
              (y / 400 | 0)
              |
              0)
             -
             32045
             |
             0)
            -
            2440588
            |
            0,
           hh_ps=caml_int64_mul(caml_int64_of_int32(hh$0),ps_count_in_hour),
           mm_ps=caml_int64_mul(caml_int64_of_int32(mm$0),ps_count_in_min),
           ss_ps=caml_int64_mul(caml_int64_of_int32(ss$0),pow),
           ps=caml_int64_add(hh_ps,caml_int64_add(mm_ps,ss_ps)),
           d$1=of_int_s(tz_offset_s),
           t$0=[0,d$0,ps];
          return of_span(add$0(t$0,neg(d$1)))}}
      return 0}
    function pp_rfc3339_error(ppf,param)
     {if(typeof param === "number")
       return 3456159 === param
               ?caml_call1(fprintf(ppf),_cz_)
               :415233371 <= param
                 ?caml_call1(fprintf(ppf),_cA_)
                 :caml_call1(fprintf(ppf),_cB_);
      var cs=param[2];
      function pp_chars(ppf,param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var cs=param$0[2],c=param$0[1];
            caml_call2(fprintf(ppf),_cC_,c);
            var param$0=cs;
            continue}
          return 0}}
      return caml_call3(fprintf(ppf),_cD_,pp_chars,cs)}
    var RFC3339=[248,_cE_,caml_fresh_oo_id(0)];
    function error(r,e){throw [0,RFC3339,r,e]}
    function error_pos(p,e){return error([0,p,p],e)}
    function error_exp_digit(p){return error_pos(p,_cF_)}
    function is_digit(param)
     {var switcher=param - 48 | 0;return 9 < switcher >>> 0?0:1}
    function parse_digits(count,k,max,s)
     {var stop=(k + count | 0) - 1 | 0;
      if(max < stop)return error_pos(max,3456159);
      var k$0=k,acc=0;
      for(;;)
       {if(stop < k$0)return acc;
        if(is_digit(caml_string_get(s,k$0)))
         {var
           acc$0=((acc * 10 | 0) + caml_string_get(s,k$0) | 0) - 48 | 0,
           k$1=k$0 + 1 | 0,
           k$0=k$1,
           acc=acc$0;
          continue}
        return error_exp_digit(k$0)}}
    function parse_char(c,pos,max,s)
     {return max < pos
              ?error_pos(max,3456159)
              :caml_string_get(s,pos) === c
                ?0
                :error_pos(pos,[0,498443355,[0,c,0]])}
    function parse_dt_sep(strict,pos,max,s)
     {if(max < pos)return error_pos(max,3456159);
      var param=caml_string_get(s,pos),switcher=param - 33 | 0,switch$0=0;
      if(82 < switcher >>> 0)
       {var switcher$0=switcher + 1 | 0;
        if(! (84 < switcher$0 >>> 0) && ! strict){var _lV_=1;switch$0 = 1}}
      else
       if(51 === switcher){var _lV_=1;switch$0 = 1}
      if(! switch$0)var _lV_=0;
      if(_lV_)return 0;
      var _lW_=strict?0:_cH_;
      return error_pos(pos,[0,498443355,append(_cG_,_lW_)])}
    function decide_frac_or_tz(strict,pos,max,s)
     {if(max < pos)return error_pos(max,3456159);
      var c=caml_string_get(s,pos),switch$0=0;
      if(90 <= c)
       {if(122 === c)
         {if(! strict)return 18854}
        else
         if(! (91 <= c))switch$0 = 1}
      else
       if(44 <= c)
        {if(! (47 <= c))
          {var switcher=c - 44 | 0;
           switch(switcher)
            {case 0:break;case 1:switch$0 = 1;break;default:return 781960526}}}
       else
        if(43 <= c)switch$0 = 1;
      if(switch$0)return 18854;
      var _lU_=strict?0:_cJ_,chars=append(_cI_,_lU_);
      return error_pos(pos,[0,498443355,chars])}
    function parse_frac_ps(pos,max,s)
     {if(max < pos)return error_pos(max,3456159);
      if(is_digit(caml_string_get(s,pos)))
       {var k=pos,acc$0=acc,pow$0=pow;
        for(;;)
         {if(max < k)return error_pos(max,3456159);
          if(is_digit(caml_string_get(s,k)))
           {var count=(k - pos | 0) + 1 | 0;
            if(12 < count){var k$0=k + 1 | 0,k=k$0;continue}
            var
             pow$1=caml_int64_div(pow$0,_cK_),
             acc$1=
              caml_int64_add
               (acc$0,
                caml_int64_mul
                 (caml_int64_of_int32(caml_string_get(s,k) - 48 | 0),pow$1)),
             k$1=k + 1 | 0,
             k=k$1,
             acc$0=acc$1,
             pow$0=pow$1;
            continue}
          return [0,[0,acc$0],k]}}
      return error_exp_digit(pos)}
    function parse_tz_s(strict,pos,max,s)
     {function parse_tz_mag(sign,hh_pos)
       {var mm_pos=hh_pos + 3 | 0,hh=parse_digits(2,hh_pos,max,s);
        parse_char(58,mm_pos - 1 | 0,max,s);
        var mm=parse_digits(2,mm_pos,max,s);
        if(23 < hh)return error([0,hh_pos,hh_pos + 1 | 0],415233371);
        if(59 < mm)return error([0,mm_pos,mm_pos + 1 | 0],415233371);
        var
         secs=(hh * 3600 | 0) + (mm * 60 | 0) | 0,
         _lS_=0 === secs?1:0,
         _lT_=_lS_?-1 === sign?1:0:_lS_,
         tz_s=_lT_?0:[0,caml_mul(sign,secs)];
        return [0,tz_s,mm_pos + 1 | 0]}
      if(max < pos)return error_pos(max,3456159);
      var c=caml_string_get(s,pos);
      if(90 === c)return [0,_cL_,pos];
      if(46 <= c)
       {if(122 === c && ! strict)return [0,_cO_,pos]}
      else
       if(43 <= c)
        {var switcher=c - 43 | 0;
         switch(switcher)
          {case 0:return parse_tz_mag(1,pos + 1 | 0);
           case 1:break;
           default:return parse_tz_mag(-1,pos + 1 | 0)}}
      var _lR_=strict?0:_cN_,chars=append(_cM_,_lR_);
      return error_pos(pos,[0,498443355,chars])}
    function of_rfc3339(opt,_lL_,_lK_,s)
     {if(opt)var sth=opt[1],strict=sth;else var strict=0;
      if(_lL_)var sth$0=_lL_[1],sub=sth$0;else var sub=0;
      if(_lK_)var sth$1=_lK_[1],start=sth$1;else var start=0;
      try
       {var s_len=caml_ml_string_length(s),max=s_len - 1 | 0,switch$0=0;
        if(0 !== s_len && 0 <= start && ! (max < start))
         {var
           m_pos=start + 5 | 0,
           d_pos=m_pos + 3 | 0,
           hh_pos=d_pos + 3 | 0,
           mm_pos=hh_pos + 3 | 0,
           ss_pos=mm_pos + 3 | 0,
           decide_pos=ss_pos + 2 | 0,
           y=parse_digits(4,start,max,s);
          parse_char(45,m_pos - 1 | 0,max,s);
          var m=parse_digits(2,m_pos,max,s);
          parse_char(45,d_pos - 1 | 0,max,s);
          var d=parse_digits(2,d_pos,max,s);
          parse_dt_sep(strict,hh_pos - 1 | 0,max,s);
          var hh=parse_digits(2,hh_pos,max,s);
          parse_char(58,mm_pos - 1 | 0,max,s);
          var mm=parse_digits(2,mm_pos,max,s);
          parse_char(58,ss_pos - 1 | 0,max,s);
          var
           ss=parse_digits(2,ss_pos,max,s),
           match=decide_frac_or_tz(strict,decide_pos,max,s);
          if(781960526 <= match)
           var
            _lN_=parse_frac_ps(decide_pos + 1 | 0,max,s),
            tz_pos=_lN_[2],
            frac=_lN_[1];
          else
           var tz_pos=decide_pos,frac=0;
          var
           match$0=parse_tz_s(strict,tz_pos,max,s),
           last_pos=match$0[2],
           tz_s_opt=match$0[1];
          if(tz_s_opt)var s$0=tz_s_opt[1],tz_s=s$0;else var tz_s=0;
          var match$1=of_date_time([0,[0,y,m,d],[0,[0,hh,mm,ss],tz_s]]);
          if(match$1)
           {var t=match$1[1],switch$1=0;
            if(frac)
             {var _lO_=frac[1];
              if(caml_notequal(_lO_,_cP_))
               {var match$2=add_span(t,[0,0,_lO_]);
                if(match$2)
                 var t$0=match$2[1],t$1=t$0;
                else
                 var t$1=error([0,start,last_pos],415233371)[1]}
              else
               switch$1 = 1}
            else
             switch$1 = 1;
            if(switch$1)var t$1=t;
            var switch$2=0;
            if(! sub && last_pos !== max)
             {var _lP_=error_pos(last_pos + 1 | 0,-493009593);switch$2 = 1}
            if(! switch$2)
             var _lP_=[0,[0,t$1,tz_s_opt,(last_pos - start | 0) + 1 | 0]];
            var _lQ_=_lP_}
          else
           var _lQ_=error([0,start,last_pos],415233371);
          var _lM_=_lQ_;
          switch$0 = 1}
        if(! switch$0)var _lM_=error_pos(start,3456159);
        return _lM_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === RFC3339)
         {var e=exn[3],r=exn[2];return [1,[0,76606165,[0,r,e]]]}
        throw exn}}
    var
     fields=
      to_list([0,[0,_cW_,field_codec_bookhash],[0,_cV_,field_codec_bookhash]]);
    function injector(fields)
     {var
       netident=find_field(_cX_,field_codec_bookhash,fields),
       chainid=find_field(_cY_,field_codec_bookhash,fields);
      return [0,netident,chainid]}
    function projector(param)
     {var chainid=param[2],netident=param[1];
      return to_list
              ([0,
                [0,_c0_,field_codec_bookhash,netident],
                [0,_cZ_,field_codec_bookhash,chainid]])}
    var field_codec_network=codec_record([0,fields,injector,projector]);
    function js_of_tezos_network_desc(_lJ_)
     {return to_js(field_codec_network,_lJ_)}
    var
     fields$0=
      to_list([0,[0,_c2_,field_codec_amount],[0,_c1_,field_codec_amount]]);
    function injector$0(fields)
     {var
       agency=find_field(_c3_,field_codec_amount,fields),
       provider=find_field(_c4_,field_codec_amount,fields);
      return [254,agency,provider]}
    function projector$0(param)
     {var provider=param[2],agency=param[1];
      return to_list
              ([0,
                [0,_c6_,field_codec_amount,agency],
                [0,_c5_,field_codec_amount,provider]])}
    var codec_rtGBC=codec_record([0,fields$0,injector$0,projector$0]);
    function js_of_book_charge_desc(_lI_){return to_js(codec_rtGBC,_lI_)}
    var
     fields$1=
      to_list([0,[0,_c8_,field_codec_bookhash],[0,_c7_,field_codec_bookhash]]);
    function injector$1(fields)
     {var
       contract_complexity=find_field(_c9_,field_codec_bookhash,fields),
       certification_status=find_field(_c__,field_codec_bookhash,fields);
      return [0,contract_complexity,certification_status]}
    function projector$1(param)
     {var certification_status=param[2],contract_complexity=param[1];
      return to_list
              ([0,
                [0,_da_,field_codec_bookhash,contract_complexity],
                [0,_c$_,field_codec_bookhash,certification_status]])}
    var codec_rtGBS=codec_record([0,fields$1,injector$1,projector$1]);
    function js_of_book_status_desc(_lH_){return to_js(codec_rtGBS,_lH_)}
    var
     fields$2=
      to_list
       ([0,
         [0,_dd_,field_codec_bookhash],
         [0,_dc_,field_codec_bookhash],
         [0,_db_,field_codec_bookhash]]);
    function injector$2(fields)
     {var
       title=find_field(_de_,field_codec_bookhash,fields),
       synopsis=find_field(_df_,field_codec_bookhash,fields),
       link=find_field(_dg_,field_codec_bookhash,fields);
      return [0,title,synopsis,link]}
    function projector$2(param)
     {var link=param[3],synopsis=param[2],title=param[1];
      return to_list
              ([0,
                [0,_dj_,field_codec_bookhash,title],
                [0,_di_,field_codec_bookhash,synopsis],
                [0,_dh_,field_codec_bookhash,link]])}
    var
     codec_book_reference=
      codec_record([0,fields$2,injector$2,projector$2]);
    function js_of_book_reference(_lG_)
     {return to_js(codec_book_reference,_lG_)}
    var
     fields$3=
      to_list
       ([0,
         [0,_dm_,field_codec_bookhash],
         [0,_dl_,field_codec_bookhash],
         [0,_dk_,field_codec_bookhash]]);
    function injector$3(fields)
     {var
       displayname=find_field(_dn_,field_codec_bookhash,fields),
       intro=find_field(_do_,field_codec_bookhash,fields),
       website=find_field(_dp_,field_codec_bookhash,fields);
      return [0,displayname,intro,website]}
    function projector$3(param)
     {var website=param[3],intro=param[2],displayname=param[1];
      return to_list
              ([0,
                [0,_ds_,field_codec_bookhash,displayname],
                [0,_dr_,field_codec_bookhash,intro],
                [0,_dq_,field_codec_bookhash,website]])}
    var codec_rtGPI=codec_record([0,fields$3,injector$3,projector$3]);
    function js_of_provider_info(_lF_){return to_js(codec_rtGPI,_lF_)}
    var
     fields$4=
      to_list([0,[0,_du_,field_codec_bookhash],[0,_dt_,field_codec_bookhash]]);
    function injector$4(fields)
     {var
       title=find_field(_dv_,field_codec_bookhash,fields),
       synopsis=find_field(_dw_,field_codec_bookhash,fields);
      return [0,title,synopsis]}
    function projector$4(param)
     {var synopsis=param[2],title=param[1];
      return to_list
              ([0,
                [0,_dy_,field_codec_bookhash,title],
                [0,_dx_,field_codec_bookhash,synopsis]])}
    var
     codec_book_basicinfo=codec_record([0,fields$4,injector$4,projector$4]),
     fields$5=
      to_list
       ([0,[0,_dA_,field_codec_bookhash],[0,_dz_,field_codec_succeeded]]);
    function injector$5(fields)
     {var
       contents=find_field(_dB_,field_codec_bookhash,fields),
       mandatory_consensus=find_field(_dC_,field_codec_succeeded,fields);
      return [0,contents,mandatory_consensus]}
    function projector$5(param)
     {var mandatory_consensus=param[2],contents=param[1];
      return to_list
              ([0,
                [0,_dE_,field_codec_bookhash,contents],
                [0,_dD_,field_codec_succeeded,mandatory_consensus]])}
    var
     codec_book_details_anyterm=
      codec_record([0,fields$5,injector$5,projector$5]),
     fields$6=
      to_list([0,[0,_dG_,field_codec_bookhash],[0,_dF_,field_codec_bookhash]]);
    function injector$6(fields)
     {var
       ident=find_field(_dH_,field_codec_bookhash,fields),
       desc=find_field(_dI_,field_codec_bookhash,fields);
      return [0,ident,desc]}
    function projector$6(param)
     {var desc=param[2],ident=param[1];
      return to_list
              ([0,
                [0,_dK_,field_codec_bookhash,ident],
                [0,_dJ_,field_codec_bookhash,desc]])}
    var
     codec_book_details_parameter=
      codec_record([0,fields$6,injector$6,projector$6]),
     field_codec_parameters=codec_list(codec_book_details_parameter),
     field_codec_englishterms=codec_list(codec_book_details_anyterm),
     field_codec_caveats=codec_list(codec_book_details_anyterm),
     fields$7=
      to_list
       ([0,
         [0,_dN_,field_codec_parameters],
         [0,_dM_,field_codec_englishterms],
         [0,_dL_,field_codec_caveats]]);
    function injector$7(fields)
     {var
       parameters=find_field(_dO_,field_codec_parameters,fields),
       englishterms=find_field(_dP_,field_codec_englishterms,fields),
       caveats=find_field(_dQ_,field_codec_caveats,fields);
      return [0,parameters,englishterms,caveats]}
    function projector$7(param)
     {var caveats=param[3],englishterms=param[2],parameters=param[1];
      return to_list
              ([0,
                [0,_dT_,field_codec_parameters,parameters],
                [0,_dS_,field_codec_englishterms,englishterms],
                [0,_dR_,field_codec_caveats,caveats]])}
    var
     codec_book_detailedinfo=codec_record([0,fields$7,injector$7,projector$7]),
     field_codec_spellAssistants=codec_assoc(field_codec_bookhash),
     fields$8=
      to_list
       ([0,
         [0,_d0_,field_codec_bookhash],
         [0,_dZ_,field_codec_bookhash],
         [0,_dY_,field_codec_spellAssistants],
         [0,_dX_,field_codec_bookhash],
         [0,_dW_,field_codec_bookhash],
         [0,_dV_,codec_book_basicinfo],
         [0,_dU_,codec_book_detailedinfo]]);
    function injector$8(fields)
     {var
       bookhash=find_field(_d1_,field_codec_bookhash,fields),
       tmplversion=find_field(_d2_,field_codec_bookhash,fields),
       spellAssistants=find_field(_d3_,field_codec_spellAssistants,fields),
       bookapp=find_field(_d4_,field_codec_bookhash,fields),
       provider=find_field(_d5_,field_codec_bookhash,fields),
       basicinfo=find_field(_d6_,codec_book_basicinfo,fields),
       detailedinfo=find_field(_d7_,codec_book_detailedinfo,fields);
      return [0,
              bookhash,
              tmplversion,
              spellAssistants,
              bookapp,
              provider,
              basicinfo,
              detailedinfo]}
    function projector$8(param)
     {var
       detailedinfo=param[7],
       basicinfo=param[6],
       provider=param[5],
       bookapp=param[4],
       spellAssistants=param[3],
       tmplversion=param[2],
       bookhash=param[1];
      return to_list
              ([0,
                [0,_ec_,field_codec_bookhash,bookhash],
                [0,_eb_,field_codec_bookhash,tmplversion],
                [0,_ea_,field_codec_spellAssistants,spellAssistants],
                [0,_d$_,field_codec_bookhash,bookapp],
                [0,_d__,field_codec_bookhash,provider],
                [0,_d9_,codec_book_basicinfo,basicinfo],
                [0,_d8_,codec_book_detailedinfo,detailedinfo]])}
    var codec_rtBK=codec_record([0,fields$8,injector$8,projector$8]);
    function js_of_book_entity(_lE_){return to_js(codec_rtBK,_lE_)}
    var
     fields$9=
      to_list
       ([0,
         [0,_ef_,field_codec_signature],
         [0,_ee_,field_codec_bookhash],
         [0,_ed_,field_codec_bookhash]]);
    function injector$9(fields)
     {var
       ccgen=find_field(_eg_,field_codec_signature,fields),
       spellinterp_endpoint=find_field(_eh_,field_codec_bookhash,fields),
       queryinterp_endpoint=find_field(_ei_,field_codec_bookhash,fields);
      return [0,ccgen,spellinterp_endpoint,queryinterp_endpoint]}
    function projector$9(param)
     {var
       queryinterp_endpoint=param[3],
       spellinterp_endpoint=param[2],
       ccgen=param[1];
      return to_list
              ([0,
                [0,_el_,field_codec_signature,ccgen],
                [0,_ek_,field_codec_bookhash,spellinterp_endpoint],
                [0,_ej_,field_codec_bookhash,queryinterp_endpoint]])}
    var
     codec_template_entity=
      codec_record([0,fields$9,injector$9,projector$9]);
    function js_of_template_entity(_lD_)
     {return to_js(codec_template_entity,_lD_)}
    var
     fields$10=
      to_list([0,[0,_en_,field_codec_bookhash],[0,_em_,field_codec_bookhash]]);
    function injector$10(fields)
     {var
       attachmentkind=find_field(_eo_,field_codec_bookhash,fields),
       bookhash=find_field(_ep_,field_codec_bookhash,fields);
      return [0,attachmentkind,bookhash]}
    function projector$10(param)
     {var bookhash=param[2],attachmentkind=param[1];
      return to_list
              ([0,
                [0,_er_,field_codec_bookhash,attachmentkind],
                [0,_eq_,field_codec_bookhash,bookhash]])}
    var
     codec=codec_record([0,fields$10,injector$10,projector$10]),
     fields$11=
      to_list
       ([0,
         [0,_ev_,field_codec_bookhash],
         [0,_eu_,field_codec_bookhash],
         [0,_et_,field_codec_bookhash],
         [0,_es_,field_codec_bookhash]]);
    function injector$11(fields)
     {var
       attachmentkind=find_field(_ew_,field_codec_bookhash,fields),
       provider=find_field(_ex_,field_codec_bookhash,fields),
       synopsis=find_field(_ey_,field_codec_bookhash,fields),
       website=find_field(_ez_,field_codec_bookhash,fields);
      return [0,attachmentkind,provider,synopsis,website]}
    function projector$11(param)
     {var
       website=param[4],
       synopsis=param[3],
       provider=param[2],
       attachmentkind=param[1];
      return to_list
              ([0,
                [0,_eD_,field_codec_bookhash,attachmentkind],
                [0,_eC_,field_codec_bookhash,provider],
                [0,_eB_,field_codec_bookhash,synopsis],
                [0,_eA_,field_codec_bookhash,website]])}
    var codec$0=codec_record([0,fields$11,injector$11,projector$11]);
    function encoder(param)
     {if(0 === param[0])
       {var bookhash=param[1],wrapped=[0,bkind_expr_SAABook,bookhash];
        return to_js(codec,wrapped)}
      var
       website=param[3],
       synopsis=param[2],
       provider=param[1],
       wrapped$0=[0,bkind_expr_SAAStandalone,provider,synopsis,website];
      return to_js(codec$0,wrapped$0)}
    function decoder(param)
     {if(480343960 <= param[1])
       {var
         js=param[2],
         match=of_js(codec$0,js),
         website=match[4],
         synopsis=match[3],
         provider=match[2];
        return [1,provider,synopsis,website]}
      var js$0=param[2],match$0=of_js(codec,js$0),bookhash=match$0[2];
      return [0,bookhash]}
    function brancher(js)
     {var kv=of_js(field_codec_bookhash,js.attachmentkind);
      if(caml_string_equal(kv,bkind_expr_SAABook))return 296245692;
      if(caml_string_equal(kv,bkind_expr_SAAStandalone))return 480343960;
      throw [0,Match_failure,_eE_]}
    var
     codec_spellassistant_attachmen=
      codec_variant([0,encoder,decoder,brancher]),
     fields$12=
      to_list([0,[0,_eG_,field_codec_bookhash],[0,_eF_,field_codec_bookhash]]);
    function injector$12(fields)
     {var
       language=find_field(_eH_,field_codec_bookhash,fields),
       contents=find_field(_eI_,field_codec_bookhash,fields);
      return [0,language,contents]}
    function projector$12(param)
     {var contents=param[2],language=param[1];
      return to_list
              ([0,
                [0,_eK_,field_codec_bookhash,language],
                [0,_eJ_,field_codec_bookhash,contents]])}
    var
     codec_spellassistant_code_spec=
      codec_record([0,fields$12,injector$12,projector$12]);
    to_list
     ([0,
       [0,_eM_,codec_spellassistant_attachmen],
       [0,_eL_,codec_spellassistant_code_spec]]);
    to_list([0,[0,_eO_,field_codec_bookhash],[0,_eN_,field_codec_spell]]);
    var field_codec_targetingbroker=codec_option(field_codec_bookhash);
    to_list
     ([0,
       [0,_eS_,field_codec_bookhash],
       [0,_eR_,field_codec_bookhash],
       [0,_eQ_,field_codec_spell],
       [0,_eP_,field_codec_targetingbroker]]);
    to_list
     ([0,
       [0,_eW_,field_codec_bookhash],
       [0,_eV_,field_codec_bookhash],
       [0,_eU_,field_codec_bookhash],
       [0,_eT_,field_codec_spell]]);
    var
     fields$13=
      to_list([0,[0,_eY_,field_codec_bookhash],[0,_eX_,field_codec_bookhash]]);
    function injector$13(fields)
     {var
       bookident=find_field(_eZ_,field_codec_bookhash,fields),
       bookhash=find_field(_e0_,field_codec_bookhash,fields);
      return [0,bookident,bookhash]}
    function projector$13(param)
     {var bookhash=param[2],bookident=param[1];
      return to_list
              ([0,
                [0,_e2_,field_codec_bookhash,bookident],
                [0,_e1_,field_codec_bookhash,bookhash]])}
    var
     codec_advertized_book_desc=
      codec_record([0,fields$13,injector$13,projector$13]),
     fields$14=
      to_list
       ([0,[0,_e4_,field_codec_succeeded],[0,_e3_,field_codec_bookhash]]);
    function injector$14(fields)
     {var
       valid=find_field(_e5_,field_codec_succeeded,fields),
       explanation=find_field(_e6_,field_codec_bookhash,fields);
      return [0,valid,explanation]}
    function projector$14(param)
     {var explanation=param[2],valid=param[1];
      return to_list
              ([0,
                [0,_e8_,field_codec_succeeded,valid],
                [0,_e7_,field_codec_bookhash,explanation]])}
    var
     codec$1=codec_record([0,fields$14,injector$14,projector$14]),
     fields$15=
      to_list
       ([0,[0,_e__,field_codec_succeeded],[0,_e9_,field_codec_bookhash]]);
    function injector$15(fields)
     {var
       valid=find_field(_e$_,field_codec_succeeded,fields),
       error=find_field(_fa_,field_codec_bookhash,fields);
      return [0,valid,error]}
    function projector$15(param)
     {var error=param[2],valid=param[1];
      return to_list
              ([0,
                [0,_fc_,field_codec_succeeded,valid],
                [0,_fb_,field_codec_bookhash,error]])}
    var
     codec$2=codec_record([0,fields$15,injector$15,projector$15]),
     bkind_expr_ValidSpell=1,
     bkind_expr_InvalidSpell=0;
    function encoder$0(param)
     {if(0 === param[0])
       {var
         explanation=param[1],
         wrapped=[0,bkind_expr_ValidSpell,explanation];
        return to_js(codec$1,wrapped)}
      var error=param[1],wrapped$0=[0,bkind_expr_InvalidSpell,error];
      return to_js(codec$2,wrapped$0)}
    function decoder$0(param)
     {if(-288268463 <= param[1])
       {var js=param[2],match=of_js(codec$2,js),error=match[2];
        return [1,error]}
      var js$0=param[2],match$0=of_js(codec$1,js$0),explanation=match$0[2];
      return [0,explanation]}
    function brancher$0(js)
     {var kindval=of_js(field_codec_succeeded,js.valid);
      if(kindval === 1)return -967177428;
      if(kindval === 0)return -288268463;
      throw [0,Match_failure,_fd_]}
    var
     codec_spell_verification_resul=
      codec_variant([0,encoder$0,decoder$0,brancher$0]);
    function js_of_spell_verification_resul(_lC_)
     {return to_js(codec_spell_verification_resul,_lC_)}
    var
     fields$16=
      to_list
       ([0,
         [0,_fg_,field_codec_bookhash],
         [0,_ff_,field_codec_bookhash],
         [0,_fe_,field_codec_bookhash]]);
    function injector$16(fields)
     {var
       name=find_field(_fh_,field_codec_bookhash,fields),
       email=find_field(_fi_,field_codec_bookhash,fields),
       srcaddr=find_field(_fj_,field_codec_bookhash,fields);
      return [0,name,email,srcaddr]}
    function projector$16(param)
     {var srcaddr=param[3],email=param[2],name=param[1];
      return to_list
              ([0,
                [0,_fm_,field_codec_bookhash,name],
                [0,_fl_,field_codec_bookhash,email],
                [0,_fk_,field_codec_bookhash,srcaddr]])}
    var
     codec_clerk_user_info=
      codec_record([0,fields$16,injector$16,projector$16]),
     fields$17=
      to_list([0,[0,_fo_,field_codec_bookhash],[0,_fn_,field_codec_bookhash]]);
    function injector$17(fields)
     {var
       spellkind=find_field(_fp_,field_codec_bookhash,fields),
       tmplversion=find_field(_fq_,field_codec_bookhash,fields);
      return [0,spellkind,tmplversion]}
    function projector$17(param)
     {var tmplversion=param[2],spellkind=param[1];
      return to_list
              ([0,
                [0,_fs_,field_codec_bookhash,spellkind],
                [0,_fr_,field_codec_bookhash,tmplversion]])}
    var
     codec$3=codec_record([0,fields$17,injector$17,projector$17]),
     fields$18=
      to_list
       ([0,
         [0,_fv_,field_codec_bookhash],
         [0,_fu_,field_codec_bookhash],
         [0,_ft_,field_codec_bookhash]]);
    function injector$18(fields)
     {var
       spellkind=find_field(_fw_,field_codec_bookhash,fields),
       tmplversion=find_field(_fx_,field_codec_bookhash,fields),
       sprthash=find_field(_fy_,field_codec_bookhash,fields);
      return [0,spellkind,tmplversion,sprthash]}
    function projector$18(param)
     {var sprthash=param[3],tmplversion=param[2],spellkind=param[1];
      return to_list
              ([0,
                [0,_fB_,field_codec_bookhash,spellkind],
                [0,_fA_,field_codec_bookhash,tmplversion],
                [0,_fz_,field_codec_bookhash,sprthash]])}
    var codec$4=codec_record([0,fields$18,injector$18,projector$18]);
    function encoder$1(param)
     {if(0 === param[0])
       {var
         tmplversion=param[1],
         wrapped=[0,bkind_expr_SpellOfGenesis,tmplversion];
        return to_js(codec$3,wrapped)}
      var
       sprthash=param[2],
       tmplversion$0=param[1],
       wrapped$0=[0,bkind_expr_SpellToSpirit,tmplversion$0,sprthash];
      return to_js(codec$4,wrapped$0)}
    function decoder$1(param)
     {if(348517556 <= param[1])
       {var
         js=param[2],
         match=of_js(codec$4,js),
         sprthash=match[3],
         tmplversion=match[2];
        return [1,tmplversion,sprthash]}
      var js$0=param[2],match$0=of_js(codec$3,js$0),tmplversion$0=match$0[2];
      return [0,tmplversion$0]}
    function brancher$1(js)
     {var kv=of_js(field_codec_bookhash,js.spellkind);
      if(caml_string_equal(kv,bkind_expr_SpellOfGenesis))return -160088727;
      if(caml_string_equal(kv,bkind_expr_SpellToSpirit))return 348517556;
      throw [0,Match_failure,_fC_]}
    var
     field_codec_target=codec_variant([0,encoder$1,decoder$1,brancher$1]),
     fields$19=
      to_list
       ([0,
         [0,_fF_,field_codec_network],
         [0,_fE_,field_codec_spell],
         [0,_fD_,field_codec_target]]);
    function injector$19(fields)
     {var
       network=find_field(_fG_,field_codec_network,fields),
       spell=find_field(_fH_,field_codec_spell,fields),
       target=find_field(_fI_,field_codec_target,fields);
      return [0,network,spell,target]}
    function projector$19(param)
     {var target=param[3],spell=param[2],network=param[1];
      return to_list
              ([0,
                [0,_fL_,field_codec_network,network],
                [0,_fK_,field_codec_spell,spell],
                [0,_fJ_,field_codec_target,target]])}
    var
     codec_qtFO=codec_record([0,fields$19,injector$19,projector$19]),
     fields$20=
      to_list([0,[0,_fN_,field_codec_amount],[0,_fM_,field_codec_amount]]);
    function injector$20(fields)
     {var
       agency=find_field(_fO_,field_codec_amount,fields),
       provider=find_field(_fP_,field_codec_amount,fields);
      return [254,agency,provider]}
    function projector$20(param)
     {var provider=param[2],agency=param[1];
      return to_list
              ([0,
                [0,_fR_,field_codec_amount,agency],
                [0,_fQ_,field_codec_amount,provider]])}
    var
     codec_simresult_template_fees=
      codec_record([0,fields$20,injector$20,projector$20]),
     fields$21=
      to_list([0,[0,_fT_,field_codec_amount],[0,_fS_,field_codec_amount]]);
    function injector$21(fields)
     {var
       fee=find_field(_fU_,field_codec_amount,fields),
       burn=find_field(_fV_,field_codec_amount,fields);
      return [254,fee,burn]}
    function projector$21(param)
     {var burn=param[2],fee=param[1];
      return to_list
              ([0,
                [0,_fX_,field_codec_amount,fee],
                [0,_fW_,field_codec_amount,burn]])}
    var
     codec_simresult_network_fees=
      codec_record([0,fields$21,injector$21,projector$21]),
     codec$5=codec_option(codec_simresult_template_fees),
     fields$22=
      to_list
       ([0,
         [0,_f2_,field_codec_succeeded],
         [0,_f1_,codec_simresult_network_fees],
         [0,_f0_,codec$5],
         [0,_fZ_,field_codec_amount],
         [0,_fY_,field_codec_signature]]);
    function injector$22(fields)
     {var
       succeeded=find_field(_f3_,field_codec_succeeded,fields),
       networkfees=find_field(_f4_,codec_simresult_network_fees,fields),
       param$0=map$0(function(fv){var fname=fv[1];return [0,fname,fv]},fields),
       param=param$0;
      for(;;)
       {if(param)
         {var l=param[2],match=param[1],b=match[2],a=match[1];
          if(0 !== caml_compare(a,fname)){var param=l;continue}
          var _lB_=[0,b]}
        else
         var _lB_=0;
        if(_lB_)
         {var match$0=_lB_[1],x=match$0[3],c=match$0[2];
          if(c !== codec$5)
           {var c$0=match$0[2];throw [0,Field_codec_mismatch,c$0,codec$5]}
          var templatefees=of_js(codec$5,x)}
        else
         var templatefees=of_js(codec$5,undefined$1);
        var
         rawamount=find_field(_f5_,field_codec_amount,fields),
         adjustedtxn=find_field(_f6_,field_codec_signature,fields);
        return [0,succeeded,networkfees,templatefees,rawamount,adjustedtxn]}}
    function projector$22(param)
     {var
       adjustedtxn=param[5],
       rawamount=param[4],
       templatefees=param[3],
       networkfees=param[2],
       succeeded=param[1];
      return to_list
              ([0,
                [0,_f$_,field_codec_succeeded,succeeded],
                [0,_f__,codec_simresult_network_fees,networkfees],
                [0,_f9_,codec$5,templatefees],
                [0,_f8_,field_codec_amount,rawamount],
                [0,_f7_,field_codec_signature,adjustedtxn]])}
    var
     codec$6=codec_record([0,fields$22,injector$22,projector$22]),
     fields$23=
      to_list
       ([0,[0,_gb_,field_codec_succeeded],[0,_ga_,field_codec_bookhash]]);
    function injector$23(fields)
     {var
       succeeded=find_field(_gc_,field_codec_succeeded,fields),
       error=find_field(_gd_,field_codec_bookhash,fields);
      return [0,succeeded,error]}
    function projector$23(param)
     {var error=param[2],succeeded=param[1];
      return to_list
              ([0,
                [0,_gf_,field_codec_succeeded,succeeded],
                [0,_ge_,field_codec_bookhash,error]])}
    var
     codec$7=codec_record([0,fields$23,injector$23,projector$23]),
     bkind_expr_SimulationSuccessfu=1,
     bkind_expr_SimulationFailed=0;
    function encoder$2(param)
     {if(0 === param[0])
       {var
         adjustedtxn=param[4],
         rawamount=param[3],
         templatefees=param[2],
         networkfees=param[1],
         wrapped=
          [0,
           bkind_expr_SimulationSuccessfu,
           networkfees,
           templatefees,
           rawamount,
           adjustedtxn];
        return to_js(codec$6,wrapped)}
      var error=param[1],wrapped$0=[0,bkind_expr_SimulationFailed,error];
      return to_js(codec$7,wrapped$0)}
    function decoder$2(param)
     {if(-68320223 <= param[1])
       {var
         js=param[2],
         match=of_js(codec$6,js),
         adjustedtxn=match[5],
         rawamount=match[4],
         templatefees=match[3],
         networkfees=match[2];
        return [0,networkfees,templatefees,rawamount,adjustedtxn]}
      var js$0=param[2],match$0=of_js(codec$7,js$0),error=match$0[2];
      return [1,error]}
    function brancher$2(js)
     {var kindval=of_js(field_codec_succeeded,js.succeeded);
      if(kindval === 1)return -68320223;
      if(kindval === 0)return -200361980;
      throw [0,Match_failure,_gg_]}
    var
     codec_rtSO=codec_variant([0,encoder$2,decoder$2,brancher$2]),
     fields$24=
      to_list([0,[0,_gi_,field_codec_bookhash],[0,_gh_,field_codec_bookhash]]);
    function injector$24(fields)
     {var
       label=find_field(_gj_,field_codec_bookhash,fields),
       link=find_field(_gk_,field_codec_bookhash,fields);
      return [0,label,link]}
    function projector$24(param)
     {var link=param[2],label=param[1];
      return to_list
              ([0,
                [0,_gm_,field_codec_bookhash,label],
                [0,_gl_,field_codec_bookhash,link]])}
    var
     codec_explorer_link=codec_record([0,fields$24,injector$24,projector$24]),
     codec_injection_trace=codec_list(field_codec_bookhash),
     fields$25=
      to_list
       ([0,
         [0,_gp_,field_codec_bookhash],
         [0,_go_,field_codec_bookhash],
         [0,_gn_,codec_injection_trace]]);
    function injector$25(fields)
     {var
       status=find_field(_gq_,field_codec_bookhash,fields),
       reason=find_field(_gr_,field_codec_bookhash,fields),
       logs=find_field(_gs_,codec_injection_trace,fields);
      return [0,status,reason,logs]}
    function projector$25(param)
     {var logs=param[3],reason=param[2],status=param[1];
      return to_list
              ([0,
                [0,_gv_,field_codec_bookhash,status],
                [0,_gu_,field_codec_bookhash,reason],
                [0,_gt_,codec_injection_trace,logs]])}
    var
     codec$8=codec_record([0,fields$25,injector$25,projector$25]),
     field_codec_explorerlink=codec_list(codec_explorer_link),
     fields$26=
      to_list
       ([0,
         [0,_gz_,field_codec_bookhash],
         [0,_gy_,field_codec_bookhash],
         [0,_gx_,field_codec_explorerlink],
         [0,_gw_,codec_injection_trace]]);
    function injector$26(fields)
     {var
       status=find_field(_gA_,field_codec_bookhash,fields),
       ophash=find_field(_gB_,field_codec_bookhash,fields),
       explorerlink=find_field(_gC_,field_codec_explorerlink,fields),
       logs=find_field(_gD_,codec_injection_trace,fields);
      return [0,status,ophash,explorerlink,logs]}
    function projector$26(param)
     {var logs=param[4],explorerlink=param[3],ophash=param[2],status=param[1];
      return to_list
              ([0,
                [0,_gH_,field_codec_bookhash,status],
                [0,_gG_,field_codec_bookhash,ophash],
                [0,_gF_,field_codec_explorerlink,explorerlink],
                [0,_gE_,codec_injection_trace,logs]])}
    var
     codec$9=codec_record([0,fields$26,injector$26,projector$26]),
     fields$27=
      to_list
       ([0,[0,_gJ_,field_codec_bookhash],[0,_gI_,codec_injection_trace]]);
    function injector$27(fields)
     {var
       status=find_field(_gK_,field_codec_bookhash,fields),
       logs=find_field(_gL_,codec_injection_trace,fields);
      return [0,status,logs]}
    function projector$27(param)
     {var logs=param[2],status=param[1];
      return to_list
              ([0,
                [0,_gN_,field_codec_bookhash,status],
                [0,_gM_,codec_injection_trace,logs]])}
    var
     codec$10=codec_record([0,fields$27,injector$27,projector$27]),
     fields$28=
      to_list([0,[0,_gP_,field_codec_bookhash],[0,_gO_,field_codec_bookhash]]);
    function injector$28(fields)
     {var
       status=find_field(_gQ_,field_codec_bookhash,fields),
       reason=find_field(_gR_,field_codec_bookhash,fields);
      return [0,status,reason]}
    function projector$28(param)
     {var reason=param[2],status=param[1];
      return to_list
              ([0,
                [0,_gT_,field_codec_bookhash,status],
                [0,_gS_,field_codec_bookhash,reason]])}
    var codec$11=codec_record([0,fields$28,injector$28,projector$28]);
    function encoder$3(param)
     {switch(param[0])
       {case 0:
         var
          logs=param[2],
          reason=param[1],
          wrapped=[0,bkind_expr_InjectionFailed,reason,logs];
         return to_js(codec$8,wrapped);
        case 1:
         var
          logs$0=param[3],
          explorerlink=param[2],
          ophash=param[1],
          wrapped$0=
           [0,bkind_expr_InjectionSuccessful,ophash,explorerlink,logs$0];
         return to_js(codec$9,wrapped$0);
        case 2:
         var
          logs$1=param[1],
          wrapped$1=[0,bkind_expr_InjectionProgressin,logs$1];
         return to_js(codec$10,wrapped$1);
        default:
         var
          reason$0=param[1],
          wrapped$2=[0,bkind_expr_InjectionInvalidTok,reason$0];
         return to_js(codec$11,wrapped$2)}}
    function decoder$3(param)
     {var _lA_=param[1];
      if(-424128807 <= _lA_)
       {if(954609876 <= _lA_)
         {var
           js=param[2],
           match=of_js(codec$8,js),
           logs=match[3],
           reason=match[2];
          return [0,reason,logs]}
        var js$0=param[2],match$0=of_js(codec$11,js$0),reason$0=match$0[2];
        return [3,reason$0]}
      if(-771923746 <= _lA_)
       {var js$1=param[2],match$1=of_js(codec$10,js$1),logs$0=match$1[2];
        return [2,logs$0]}
      var
       js$2=param[2],
       match$2=of_js(codec$9,js$2),
       logs$1=match$2[4],
       explorerlink=match$2[3],
       ophash=match$2[2];
      return [1,ophash,explorerlink,logs$1]}
    function brancher$3(js)
     {var kv=of_js(field_codec_bookhash,js.status);
      if(caml_string_equal(kv,bkind_expr_InjectionFailed))return 954609876;
      if(caml_string_equal(kv,bkind_expr_InjectionSuccessful))
       return -784751375;
      if(caml_string_equal(kv,bkind_expr_InjectionProgressin))
       return -771923746;
      if(caml_string_equal(kv,bkind_expr_InjectionInvalidTok))
       return -424128807;
      throw [0,Match_failure,_gU_]}
    var
     codec_rtCOI=codec_variant([0,encoder$3,decoder$3,brancher$3]),
     template_entity=[0,of_string(_gX_),_gW_,_gV_];
    function books(param)
     {if(caml_string_notequal(param,_gY_))
       {if(caml_string_notequal(param,_gZ_))
         {if(caml_string_notequal(param,_g0_))throw Not_found;return _g1_}
        return _g2_}
      return _g3_}
    function book_charges(param)
     {if(caml_string_notequal(param,_ha_))
       {if(caml_string_notequal(param,_hb_))
         {if(caml_string_notequal(param,_hc_))throw Not_found;return _hd_}
        return _he_}
      return _hf_}
    var
     field_codec_fund_owners=codec_list(field_codec_bookhash),
     fields$29=
      to_list
       ([0,
         [0,_ho_,field_codec_fund_owners],
         [0,_hn_,field_codec_amount],
         [0,_hm_,field_codec_bookhash]]);
    function injector$29(fields)
     {var
       fund_owners=find_field(_hp_,field_codec_fund_owners,fields),
       fund_amount=find_field(_hq_,field_codec_amount,fields),
       unfrozen=find_field(_hr_,field_codec_bookhash,fields);
      return [0,fund_owners,fund_amount,unfrozen]}
    function projector$29(param)
     {var unfrozen=param[3],fund_amount=param[2],fund_owners=param[1];
      return to_list
              ([0,
                [0,_hu_,field_codec_fund_owners,fund_owners],
                [0,_ht_,field_codec_amount,fund_amount],
                [0,_hs_,field_codec_bookhash,unfrozen]])}
    var
     codec_genparam=codec_record([0,fields$29,injector$29,projector$29]),
     fields$30=
      to_list([0,[0,_hw_,field_codec_amount],[0,_hv_,field_codec_bookhash]]);
    function injector$30(fields)
     {var
       amount=find_field(_hx_,field_codec_amount,fields),
       beneficiary=find_field(_hy_,field_codec_bookhash,fields);
      return [0,amount,beneficiary]}
    function projector$30(param)
     {var beneficiary=param[2],amount=param[1];
      return to_list
              ([0,
                [0,_hA_,field_codec_amount,amount],
                [0,_hz_,field_codec_bookhash,beneficiary]])}
    var codec_withdraw=codec_record([0,fields$30,injector$30,projector$30]);
    function spell_verifiers(param)
     {if(caml_string_notequal(param,_hB_))
       {if(caml_string_notequal(param,_hC_))throw Not_found;
        return function(js)
         {var
           spell=of_js(codec_withdraw,js),
           verification_result=spell[1] <= 0.?[1,_hD_]:[0,0];
          if(0 === verification_result[0])
           var
            json=caml_string_of_jsstring(output(js)),
            explanation=symbol(_hE_,json),
            _lz_=[0,explanation];
          else
           var error=verification_result[1],_lz_=[1,error];
          return js_of_spell_verification_resul(_lz_)}}
      return function(js)
       {var spell=of_js(codec_genparam,js);
        function _ls_(param)
         {function _lw_(param)
           {var v=of_rfc3339(0,0,0,spell[3]);
            if(0 === v[0])
             var match$0=v;
            else
             var
              _ly_=v[1][2],
              err=_ly_[2],
              match=_ly_[1],
              e=match[2],
              s=match[1],
              match$0=
               [1,
                [0,
                 3854881,
                 caml_call4(kasprintf(id,fmt),s,e,pp_rfc3339_error,err)]];
            if(0 === match$0[0])return [0,0];
            var match$1=match$0[1],msg=match$1[2];
            return [1,symbol(_hF_,msg)]}
          var _lx_=spell[2] <= 0.?[1,_hG_]:[0,0];
          return symbol_bind(_lx_,_lw_)}
        var
         _lt_=spell[1]?0:1,
         _lu_=_lt_?[1,_hH_]:[0,0],
         param=symbol_bind(_lu_,_ls_);
        if(0 === param[0])
         var
          json=caml_string_of_jsstring(output(js)),
          explanation=symbol(_hI_,json),
          _lv_=[0,explanation];
        else
         var error=param[1],_lv_=[1,error];
        return js_of_spell_verification_resul(_lv_)}}
    var txn=to_bytes(_hJ_),undefined$2=undefined;
    function protect_not_found(f)
     {try
       {var _lq_=caml_call1(f,0);return _lq_}
      catch(_lr_)
       {_lr_ = caml_wrap_exception(_lr_);
        if(_lr_ === Not_found)return undefined$2;
        throw _lr_}}
    function kont(msg)
     {global.console.log(caml_jsstring_of_string(msg));return 0}
    function debug(_lp_){return kasprintf(kont,_lp_)}
    function debugs(str){return caml_call1(debug(_hQ_),str)}
    var
     field_codec_networks=codec_list(field_codec_network),
     fields$31=to_list([0,[0,_hR_,field_codec_networks]]);
    function injector$31(fields)
     {var networks=find_field(_hS_,field_codec_networks,fields);
      return [0,networks]}
    function projector$31(param)
     {var networks=param[1];
      return to_list([0,[0,_hT_,field_codec_networks,networks]])}
    var
     codec_rtLATN=codec_record([0,fields$31,injector$31,projector$31]),
     field_codec_books=codec_list(codec_advertized_book_desc),
     fields$32=to_list([0,[0,_hU_,field_codec_books]]);
    function injector$32(fields)
     {var books=find_field(_hV_,field_codec_books,fields);return [0,books]}
    function projector$32(param)
     {var books=param[1];return to_list([0,[0,_hW_,field_codec_books,books]])}
    var
     codec_rtLAB=codec_record([0,fields$32,injector$32,projector$32]),
     fields$33=to_list([0,[0,_hX_,field_codec_bookhash]]);
    function injector$33(fields)
     {var bookhash=find_field(_hY_,field_codec_bookhash,fields);
      return [0,bookhash]}
    function projector$33(param)
     {var bookhash=param[1];
      return to_list([0,[0,_hZ_,field_codec_bookhash,bookhash]])}
    var
     codec_qtGBKR=codec_record([0,fields$33,injector$33,projector$33]),
     field_codec_specifications=codec_list(codec_book_reference),
     fields$34=to_list([0,[0,_h0_,field_codec_specifications]]);
    function injector$34(fields)
     {var specifications=find_field(_h1_,field_codec_specifications,fields);
      return [0,specifications]}
    function projector$34(param)
     {var specifications=param[1];
      return to_list([0,[0,_h2_,field_codec_specifications,specifications]])}
    var
     codec_rtGBKR=codec_record([0,fields$34,injector$34,projector$34]),
     fields$35=to_list([0,[0,_h3_,field_codec_bookhash]]);
    function injector$35(fields)
     {var provider=find_field(_h4_,field_codec_bookhash,fields);
      return [0,provider]}
    function projector$35(param)
     {var provider=param[1];
      return to_list([0,[0,_h5_,field_codec_bookhash,provider]])}
    var
     codec_qtGPI=codec_record([0,fields$35,injector$35,projector$35]),
     fields$36=to_list([0,[0,_h6_,field_codec_bookhash]]);
    function injector$36(fields)
     {var bookhash=find_field(_h7_,field_codec_bookhash,fields);
      return [0,bookhash]}
    function projector$36(param)
     {var bookhash=param[1];
      return to_list([0,[0,_h8_,field_codec_bookhash,bookhash]])}
    var
     codec_qtGBC=codec_record([0,fields$36,injector$36,projector$36]),
     fields$37=to_list([0,[0,_h9_,field_codec_bookhash]]);
    function injector$37(fields)
     {var bookhash=find_field(_h__,field_codec_bookhash,fields);
      return [0,bookhash]}
    function projector$37(param)
     {var bookhash=param[1];
      return to_list([0,[0,_h$_,field_codec_bookhash,bookhash]])}
    var
     codec_qtGBS=codec_record([0,fields$37,injector$37,projector$37]),
     _ia_=[0,0,0,0];
    function _ib_
     (self,
      listAvailableTezosNetworks,
      listAdvertizedBooks,
      getBookReferences,
      getProviderInfo,
      getBookCharges,
      getBookStatus)
     {if(! _ia_[1])
       {var
         _k__=create_table(_hM_),
         _k$_=new_variable(_k__,_ic_),
         _la_=get_method_labels(_k__,_hP_),
         _lb_=_la_[1],
         _lc_=_la_[2],
         _ld_=_la_[3],
         _le_=_la_[4],
         _lf_=_la_[5],
         _lg_=_la_[6],
         _lh_=
          function(self_1)
           {var env=self_1[1 + _k$_];return caml_call1(env[2],env[1])},
         _li_=
          function(self_1)
           {var env=self_1[1 + _k$_];return caml_call1(env[3],env[1])},
         _lj_=
          function(self_1)
           {var env=self_1[1 + _k$_];return caml_call1(env[4],env[1])},
         _lk_=
          function(self_1)
           {var env=self_1[1 + _k$_];return caml_call1(env[5],env[1])},
         _ll_=
          function(self_1)
           {var env=self_1[1 + _k$_];return caml_call1(env[6],env[1])};
        set_methods
         (_k__,
          [0,
           _lb_,
           function(self_1)
            {var env=self_1[1 + _k$_];return caml_call1(env[7],env[1])},
           _lc_,
           _ll_,
           _lf_,
           _lk_,
           _ld_,
           _lj_,
           _lg_,
           _li_,
           _le_,
           _lh_]);
        var
         _lm_=
          function(_ln_)
           {var _lo_=create_object_opt(0,_k__);
            _lo_[1 + _k$_] = _ln_;
            return _lo_};
        init_class(_k__);
        _ia_[1] = _lm_}
      return caml_call1
              (_ia_[1],
               [0,
                self,
                getBookStatus,
                getBookCharges,
                getProviderInfo,
                getBookReferences,
                listAdvertizedBooks,
                listAvailableTezosNetworks])}
    function _id_(param,q)
     {return symbol$0
              (protect_not_found,
               function(param)
                {var param$0=of_js(codec_qtGBS,q),bookhash=param$0[1];
                 if(caml_string_notequal(bookhash,_hg_))
                  if(caml_string_notequal(bookhash,_hh_))
                   {if(caml_string_notequal(bookhash,_hi_))throw Not_found;
                    var _k9_=_hj_}
                  else
                   var _k9_=_hk_;
                 else
                  var _k9_=_hl_;
                 return to_js(codec_rtGBS,_k9_)})}
    function _ie_(param,q)
     {return symbol$0
              (protect_not_found,
               function(param)
                {var param$0=of_js(codec_qtGBC,q),bookhash=param$0[1];
                 return to_js(codec_rtGBC,book_charges(bookhash))})}
    function _if_(param,q)
     {return symbol$0
              (protect_not_found,
               function(param)
                {var param$0=of_js(codec_qtGPI,q),provider=param$0[1];
                 if(caml_string_notequal(provider,_g__))throw Not_found;
                 return to_js(codec_rtGPI,_g$_)})}
    function _ig_(param,q)
     {return symbol$0
              (protect_not_found,
               function(param)
                {var param$0=of_js(codec_qtGBKR,q),bookhash=param$0[1];
                 if(caml_string_notequal(bookhash,_g4_))
                  if(caml_string_notequal(bookhash,_g5_))
                   {if(caml_string_notequal(bookhash,_g6_))throw Not_found;
                    var _k8_=_g7_}
                  else
                   var _k8_=_g8_;
                 else
                  var _k8_=_g9_;
                 return to_js(codec_rtGBKR,[0,_k8_])})}
    function _ih_(param){return to_js(codec_rtLAB,[0,advertized_books])}
    function _ii_(param){return to_js(codec_rtLATN,[0,availableNetworks])}
    var
     jsapi=
      function(t10,t11,t12,t13,t14,t15,param)
        {return {"listAvailableTezosNetworks":caml_js_wrap_meth_callback(t10),
                 "listAdvertizedBooks":caml_js_wrap_meth_callback(t11),
                 "getBookReferences":caml_js_wrap_meth_callback(t12),
                 "getProviderInfo":caml_js_wrap_meth_callback(t13),
                 "getBookCharges":caml_js_wrap_meth_callback(t14),
                 "getBookStatus":caml_js_wrap_meth_callback(t15)}}
       (_ii_,_ih_,_ig_,_if_,_ie_,_id_,_ib_),
     fields$38=to_list([0,[0,_ij_,field_codec_bookhash]]);
    function injector$38(fields)
     {var sahash=find_field(_ik_,field_codec_bookhash,fields);
      return [0,sahash]}
    function projector$38(param)
     {var sahash=param[1];
      return to_list([0,[0,_il_,field_codec_bookhash,sahash]])}
    var
     codec_qtSV=codec_record([0,fields$38,injector$38,projector$38]),
     fields$39=to_list([0,[0,_im_,field_codec_spell]]);
    function injector$39(fields)
     {var verifier=find_field(_in_,field_codec_spell,fields);
      return [0,verifier]}
    function projector$39(param)
     {var verifier=param[1];
      return to_list([0,[0,_io_,field_codec_spell,verifier]])}
    var
     codec_rtSV=codec_record([0,fields$39,injector$39,projector$39]),
     fields$40=
      to_list
       ([0,
         [0,_ir_,field_codec_spell],
         [0,_iq_,field_codec_signature],
         [0,_ip_,field_codec_target]]);
    function injector$40(fields)
     {var
       spell=find_field(_is_,field_codec_spell,fields),
       txn=find_field(_it_,field_codec_signature,fields),
       target=find_field(_iu_,field_codec_target,fields);
      return [0,spell,txn,target]}
    function projector$40(param)
     {var target=param[3],txn=param[2],spell=param[1];
      return to_list
              ([0,
                [0,_ix_,field_codec_spell,spell],
                [0,_iw_,field_codec_signature,txn],
                [0,_iv_,field_codec_target,target]])}
    var
     codec_simprivinfo=
      codec_record([0,fields$40,injector$40,projector$40]);
    function checknetwork(network)
     {var _k7_=caml_notequal(network,fixed_network);
      return _k7_?failwith(_iy_):_k7_}
    var
     fields$41=
      to_list([0,[0,_iA_,field_codec_signature],[0,_iz_,codec_simprivinfo]]);
    function injector$41(fields)
     {var
       unsignedtxn=find_field(_iB_,field_codec_signature,fields),
       simprivinfo=find_field(_iC_,codec_simprivinfo,fields);
      return [0,unsignedtxn,simprivinfo]}
    function projector$41(param)
     {var simprivinfo=param[2],unsignedtxn=param[1];
      return to_list
              ([0,
                [0,_iE_,field_codec_signature,unsignedtxn],
                [0,_iD_,codec_simprivinfo,simprivinfo]])}
    var
     codec_rtFO=codec_record([0,fields$41,injector$41,projector$41]),
     fields$42=
      to_list
       ([0,
         [0,_iH_,field_codec_network],
         [0,_iG_,field_codec_signature],
         [0,_iF_,codec_simprivinfo]]);
    function injector$42(fields)
     {var
       network=find_field(_iI_,field_codec_network,fields),
       txn=find_field(_iJ_,field_codec_signature,fields),
       simprivinfo=find_field(_iK_,codec_simprivinfo,fields);
      return [0,network,txn,simprivinfo]}
    function projector$42(param)
     {var simprivinfo=param[3],txn=param[2],network=param[1];
      return to_list
              ([0,
                [0,_iN_,field_codec_network,network],
                [0,_iM_,field_codec_signature,txn],
                [0,_iL_,codec_simprivinfo,simprivinfo]])}
    var
     codec_qtSO=codec_record([0,fields$42,injector$42,projector$42]),
     fields$43=
      to_list
       ([0,
         [0,_i0_,field_codec_signature],
         [0,_iZ_,field_codec_signature],
         [0,_iY_,field_codec_bookhash],
         [0,_iX_,field_codec_signature],
         [0,_iW_,field_codec_network]]);
    function injector$43(fields)
     {var
       unsignedtxn=find_field(_i1_,field_codec_signature,fields),
       signer=find_field(_i2_,field_codec_signature,fields),
       srcaddr=find_field(_i3_,field_codec_bookhash,fields),
       signature=find_field(_i4_,field_codec_signature,fields),
       network=find_field(_i5_,field_codec_network,fields);
      return [0,unsignedtxn,signer,srcaddr,signature,network]}
    function projector$43(param)
     {var
       network=param[5],
       signature=param[4],
       srcaddr=param[3],
       signer=param[2],
       unsignedtxn=param[1];
      return to_list
              ([0,
                [0,_i__,field_codec_signature,unsignedtxn],
                [0,_i9_,field_codec_signature,signer],
                [0,_i8_,field_codec_bookhash,srcaddr],
                [0,_i7_,field_codec_signature,signature],
                [0,_i6_,field_codec_network,network]])}
    var
     codec_qtIO=codec_record([0,fields$43,injector$43,projector$43]),
     fields$44=
      to_list
       ([0,
         [0,_jb_,field_codec_bookhash],
         [0,_ja_,field_codec_bookhash],
         [0,_i$_,field_codec_minqueryinterval]]);
    function injector$44(fields)
     {var
       injtoken=find_field(_jc_,field_codec_bookhash,fields),
       timeout=find_field(_jd_,field_codec_bookhash,fields),
       minqueryinterval=find_field(_je_,field_codec_minqueryinterval,fields);
      return [0,injtoken,timeout,minqueryinterval]}
    function projector$44(param)
     {var minqueryinterval=param[3],timeout=param[2],injtoken=param[1];
      return to_list
              ([0,
                [0,_jh_,field_codec_bookhash,injtoken],
                [0,_jg_,field_codec_bookhash,timeout],
                [0,_jf_,field_codec_minqueryinterval,minqueryinterval]])}
    var
     codec_rtIO=codec_record([0,fields$44,injector$44,projector$44]),
     fields$45=to_list([0,[0,_jk_,field_codec_bookhash]]);
    function injector$45(fields)
     {var injtoken=find_field(_jl_,field_codec_bookhash,fields);
      return [0,injtoken]}
    function projector$45(param)
     {var injtoken=param[1];
      return to_list([0,[0,_jm_,field_codec_bookhash,injtoken]])}
    var
     codec_qtCOI=codec_record([0,fields$45,injector$45,projector$45]),
     _jC_=[0,0,0,0];
    function _jD_
     (self,
      getSpellVerifier,
      defaultClerkUserInfo,
      forgeOperation,
      simulateOperation,
      injectOperation,
      checkOperationInjection)
     {if(! _jC_[1])
       {var
         _kQ_=create_table(_hO_),
         _kR_=new_variable(_kQ_,_jE_),
         _kS_=get_method_labels(_kQ_,_hL_),
         _kT_=_kS_[1],
         _kU_=_kS_[2],
         _kV_=_kS_[3],
         _kW_=_kS_[4],
         _kX_=_kS_[5],
         _kY_=_kS_[6],
         _kZ_=
          function(self_2)
           {var env=self_2[1 + _kR_];return caml_call1(env[2],env[1])},
         _k0_=
          function(self_2)
           {var env=self_2[1 + _kR_];return caml_call1(env[3],env[1])},
         _k1_=
          function(self_2)
           {var env=self_2[1 + _kR_];return caml_call1(env[4],env[1])},
         _k2_=
          function(self_2)
           {var env=self_2[1 + _kR_];return caml_call1(env[5],env[1])},
         _k3_=
          function(self_2)
           {var env=self_2[1 + _kR_];return caml_call1(env[6],env[1])};
        set_methods
         (_kQ_,
          [0,
           _kV_,
           function(self_2)
            {var env=self_2[1 + _kR_];return caml_call1(env[7],env[1])},
           _kX_,
           _k3_,
           _kW_,
           _k2_,
           _kT_,
           _k1_,
           _kU_,
           _k0_,
           _kY_,
           _kZ_]);
        var
         _k4_=
          function(_k5_)
           {var _k6_=create_object_opt(0,_kQ_);
            _k6_[1 + _kR_] = _k5_;
            return _k6_};
        init_class(_kQ_);
        _jC_[1] = _k4_}
      return caml_call1
              (_jC_[1],
               [0,
                self,
                checkOperationInjection,
                injectOperation,
                simulateOperation,
                forgeOperation,
                defaultClerkUserInfo,
                getSpellVerifier])}
    function _jF_(param,q)
     {var
       param$0=of_js(codec_qtCOI,q),
       injtoken=param$0[1],
       suggestion=symbol(_jo_,symbol(known_tokens,_jn_));
      if(caml_string_notequal(injtoken,_jp_))
       if(caml_string_notequal(injtoken,_jq_))
        var
         _kP_=
          caml_string_notequal(injtoken,_jr_)
           ?caml_string_notequal(injtoken,_js_)?[3,symbol(_jt_,injtoken)]:_ju_
           :_jv_;
       else
        var
         _kN_=[0,symbol(_jw_,injtoken),[0,suggestion,0]],
         _kO_=[0,[0,_jy_,symbol(_jx_,ophash)],0],
         _kP_=[1,ophash,[0,[0,_jA_,symbol(_jz_,ophash)],_kO_],_kN_];
      else
       var _kP_=[2,[0,symbol(_jB_,injtoken),[0,suggestion,0]]];
      return to_js(codec_rtCOI,_kP_)}
    function _jG_(param,q)
     {var param$0=of_js(codec_qtIO,q),network=param$0[5];
      checknetwork(network);
      var now=new date_ms().getTime(),now$0=now / 1000.,secs=now$0 + 300;
      caml_call1(debug(_ji_),now$0);
      caml_call1(debug(_jj_),secs);
      var minqueryinterval=100;
      if(secs != secs)
       var match$0=0;
      else
       {var days=Math.floor(secs / 86400.),switch$0=0;
        if(days < -2147483648 || 2147483647 < days)
         switch$0 = 1;
        else
         {var rem_s=secs % 86400.,rem_s$0=rem_s < 0.?86400. + rem_s:rem_s;
          if(86400. <= rem_s$0)
           var match$0=[0,[0,(days | 0) + 1 | 0,_cw_]];
          else
           var
            match=caml_modf_float(rem_s$0),
            rem_s$1=match[2],
            frac_s=match[1],
            rem_ps=caml_int64_mul(caml_int64_of_float(rem_s$1),pow),
            frac_ps=caml_int64_of_float(frac_s * 1000000000000.),
            match$0=[0,[0,days | 0,caml_int64_add(rem_ps,frac_ps)]]}
        if(switch$0)var match$0=0}
      if(match$0)var d$1=match$0[1],_kL_=of_span(d$1);else var _kL_=0;
      if(_kL_)var v=_kL_[1],_kM_=v;else var _kM_=invalid_arg(_d_);
      var ps$0=_kM_[2],buf=create$0(255),frac=0;
      if(tz_offset_s)
       {var tz=tz_offset_s[1],switch$1=0;
        if(-86340 <= tz && tz <= 86340 && 0 === (tz % 60 | 0))
         {var _kK_=[0,tz,0];switch$1 = 1}
        if(! switch$1)var _kK_=_cQ_;
        var tz_unknown=_kK_[2],sth=_kK_[1]}
      else
       var tz_unknown=1,sth=0;
      var
       opt=[0,sth],
       tz_offset_s$0=opt?sth:0,
       match$1=add_span(_kM_,of_int_s(tz_offset_s$0));
      if(match$1)
       var
        local=match$1[1],
        tz_offset_s$1=tz_offset_s$0,
        ps=local[2],
        d$2=local[1];
      else
       var tz_offset_s$1=0,ps=_kM_[2],d$2=_kM_[1];
      var
       jd=d$2 + 2440588 | 0,
       a=jd + 32044 | 0,
       b=((4 * a | 0) + 3 | 0) / 146097 | 0,
       c=a - ((146097 * b | 0) / 4 | 0) | 0,
       d=((4 * c | 0) + 3 | 0) / 1461 | 0,
       e=c - ((1461 * d | 0) / 4 | 0) | 0,
       m=((5 * e | 0) + 2 | 0) / 153 | 0,
       d$0=(e - (((153 * m | 0) + 2 | 0) / 5 | 0) | 0) + 1 | 0,
       m$0=(m + 3 | 0) - (12 * (m / 10 | 0) | 0) | 0,
       y=(((100 * b | 0) + d | 0) - 4800 | 0) + (m / 10 | 0) | 0,
       hh=caml_int64_to_int32(caml_int64_div(ps,ps_count_in_hour)),
       hh_rem=caml_int64_mod(ps,ps_count_in_hour),
       ss=caml_int64_to_int32(caml_int64_div(hh_rem,ps_count_in_min)),
       mm_rem=caml_int64_mod(hh_rem,ps_count_in_min),
       mm=caml_int64_to_int32(caml_int64_div(mm_rem,pow));
      caml_call7(bprintf(buf,_cR_),y,m$0,d$0,84,hh,ss,mm);
      if(0 !== frac)
       {var
         _kJ_=
          caml_int64_div
           (caml_int64_mod(ps$0,pow),
            caml_check_bound(frac_div,frac)[1 + frac]);
        caml_call2(bprintf(buf,_cS_),frac,_kJ_)}
      var switch$2=0;
      if(0 === tz_offset_s$1 && ! tz_unknown){bprintf(buf,_cU_);switch$2 = 1}
      if(! switch$2)
       {var switch$3=0;
        if(0 <= tz_offset_s$1 && ! tz_unknown){var tz_sign=43;switch$3 = 1}
        if(! switch$3)var tz_sign=45;
        var
         tz_min=abs(tz_offset_s$1 / 60 | 0),
         tz_hh=tz_min / 60 | 0,
         tz_mm=tz_min % 60 | 0;
        caml_call3(bprintf(buf,_cT_),tz_sign,tz_hh,tz_mm)}
      var timeout=contents(buf);
      return to_js(codec_rtIO,[0,injtoken,timeout,minqueryinterval])}
    function _jH_(param$0,q)
     {var
       param$2=of_js(codec_qtSO,q),
       match=param$2[3],
       target=match[3],
       spell=match[1],
       txn=param$2[2],
       network=param$2[1];
      checknetwork(network);
      function _kD_(param)
       {var templatefees=param[4],networkfees=param[3],rawamount=param[2];
        return [0,[0,networkfees,templatefees,rawamount,txn]]}
      var tmplversion=target[1];
      if(caml_string_equal(tmplversion,_iO_))
       var
        book=books(_iP_),
        sahash=0 === target[0]?_iQ_:_iU_,
        sv=spell_verifiers(sahash),
        _kE_=
         function(param)
          {if(0 === target[0])
            var
             match=book_charges(book[1]),
             provider=match[2],
             agency=match[1],
             templatefees=[254,agency,provider],
             _kI_=[0,spell.fund_amount,_iR_,[0,templatefees]];
           else
            var _kI_=_iS_;
           var templatefees$0=_kI_[3],networkfees=_kI_[2],rawamount=_kI_[1];
           return [0,[0,book,rawamount,networkfees,templatefees$0]]},
        param$1=of_js(codec_spell_verification_resul,caml_call1(sv,spell)),
        _kF_=0 === param$1[0]?[0,0]:[1,symbol(_iT_,sahash)],
        _kG_=symbol_bind(_kF_,_kE_);
      else
       var _kG_=[1,_iV_];
      var param=symbol_bind(_kG_,_kD_);
      if(0 === param[0])var v=param[1],_kH_=v;else var e=param[1],_kH_=[1,e];
      return to_js(codec_rtSO,_kH_)}
    function _jI_(param,q)
     {var
       param$0=of_js(codec_qtFO,q),
       target=param$0[3],
       spell=param$0[2],
       network=param$0[1];
      checknetwork(network);
      return to_js(codec_rtFO,[0,txn,[0,spell,txn,target]])}
    function _jJ_(param){return to_js(codec_clerk_user_info,clerkUserInfo)}
    function _jK_(param,q)
     {return symbol$0
              (protect_not_found,
               function(param)
                {var param$0=of_js(codec_qtSV,q),sahash=param$0[1];
                 return to_js(codec_rtSV,[0,spell_verifiers(sahash)])})}
    var
     jsapi$0=
      function(t23,t24,t25,t26,t27,t28,param)
        {return {"getSpellVerifier":caml_js_wrap_meth_callback(t23),
                 "defaultClerkUserInfo":caml_js_wrap_meth_callback(t24),
                 "forgeOperation":caml_js_wrap_meth_callback(t25),
                 "simulateOperation":caml_js_wrap_meth_callback(t26),
                 "injectOperation":caml_js_wrap_meth_callback(t27),
                 "checkOperationInjection":caml_js_wrap_meth_callback(t28)}}
       (_jK_,_jJ_,_jI_,_jH_,_jG_,_jF_,_jD_),
     fields$46=to_list([0,[0,_jL_,field_codec_bookhash]]);
    function injector$46(fields)
     {var bookhash=find_field(_jM_,field_codec_bookhash,fields);
      return [0,bookhash]}
    function projector$46(param)
     {var bookhash=param[1];
      return to_list([0,[0,_jN_,field_codec_bookhash,bookhash]])}
    var
     codec_qtBK=codec_record([0,fields$46,injector$46,projector$46]),
     _jO_=[0,0,0,0];
    function _jP_(self,getBook)
     {if(! _jO_[1])
       {var
         _kx_=create_table(_hK_),
         _ky_=new_variable(_kx_,_jQ_),
         _kz_=get_method_label(_kx_,_jR_);
        set_method
         (_kx_,
          _kz_,
          function(self_3)
           {var env=self_3[1 + _ky_];return caml_call1(env[2],env[1])});
        var
         _kA_=
          function(_kB_)
           {var _kC_=create_object_opt(0,_kx_);
            _kC_[1 + _ky_] = _kB_;
            return _kC_};
        init_class(_kx_);
        _jO_[1] = _kA_}
      return caml_call1(_jO_[1],[0,self,getBook])}
    function _jS_(param,q)
     {return symbol$0
              (protect_not_found,
               function(param)
                {var param$0=of_js(codec_qtBK,q),bookhash=param$0[1];
                 return to_js(codec_rtBK,books(bookhash))})}
    var
     jsapi$1=
      function(t30,param){return {"getBook":caml_js_wrap_meth_callback(t30)}}
       (_jS_,_jP_),
     aii_token_calc=
      [246,
       function(param)
        {var
          passin=caml_js_eval_string(_jT_),
          passin$0=map(caml_string_of_jsstring,to_option(passin)),
          token=value(passin$0,_jU_);
         caml_call2(kprintf(debugs,_jW_),_jV_,token);
         return token}];
    function aii_token(param)
     {var _kw_=caml_obj_tag(aii_token_calc);
      return 250 === _kw_
              ?aii_token_calc[1]
              :246 === _kw_?force_lazy_block(aii_token_calc):aii_token_calc}
    var
     aii_aii_endpoint_calc=
      [246,
       function(param)
        {var
          passin=caml_js_eval_string(_jX_),
          passin$0=map(caml_string_of_jsstring,to_option(passin)),
          endpoint=value(passin$0,_jY_);
         caml_call2(kprintf(debugs,_j0_),_jZ_,endpoint);
         return endpoint}];
    function aii_endpoint(param)
     {var _kv_=caml_obj_tag(aii_aii_endpoint_calc);
      return 250 === _kv_
              ?aii_aii_endpoint_calc[1]
              :246 === _kv_
                ?force_lazy_block(aii_aii_endpoint_calc)
                :aii_aii_endpoint_calc}
    var jsaxios=require("axios"),_j1_=[0,0,0,0];
    function _j2_
     (self,calculateAddressFromPublicKey,calculateAddressFromPublicKeyA)
     {if(! _j1_[1])
       {var
         _km_=create_table(_hN_),
         _kn_=new_variable(_km_,_j3_),
         _ko_=get_method_labels(_km_,shared),
         _kp_=_ko_[1],
         _kq_=_ko_[2],
         _kr_=
          function(self_5)
           {var env=self_5[1 + _kn_];return caml_call1(env[2],env[1])};
        set_methods
         (_km_,
          [0,
           _kq_,
           function(self_5)
            {var env=self_5[1 + _kn_];return caml_call1(env[3],env[1])},
           _kp_,
           _kr_]);
        var
         _ks_=
          function(_kt_)
           {var _ku_=create_object_opt(0,_km_);
            _ku_[1 + _kn_] = _kt_;
            return _ku_};
        init_class(_km_);
        _j1_[1] = _ks_}
      return caml_call1
              (_j1_[1],
               [0,
                self,
                calculateAddressFromPublicKeyA,
                calculateAddressFromPublicKey])}
    function _j4_(param,pk)
     {function on_fulfilled(resp){return resp.data}
      var
       url=symbol(aii_endpoint(0),_j5_),
       params$0=[0,[0,[0,_j6_,caml_string_of_jsstring(pk)],0]],
       list=value(params$0,0);
      function f(param)
       {var v=param[2],k=param[1];return [0,k,caml_jsstring_of_string(v)]}
      var
       params=caml_js_object(of_list(map$0(f,list))),
       promise=jsaxios.get(caml_jsstring_of_string(url),{"params":params});
      return promise.then(on_fulfilled,undefined$0)}
    function _j7_(param,pk){return "tz1NQ5Fk7eJCe1zGmngv2GRnJK9G1nEnQahQ"}
    var
     api_TezosUtilities=
      function(t35,t36,param)
        {return {"calculateAddressFromPublicKey":
                 caml_js_wrap_meth_callback(t35),
                 "calculateAddressFromPublicKeyAsync":
                 caml_js_wrap_meth_callback(t36)}}
       (_j7_,_j4_,_j2_);
    debugs(symbol(_j9_,_j8_));
    var
     _j__=js_of_template_entity(template_entity),
     _j$_=js_of_book_entity(book_entity),
     _ka_=js_of_provider_info(provider_info),
     _kb_=js_of_book_reference(book_reference),
     _kc_=js_of_book_status_desc(book_status_desc),
     _kd_=js_of_book_charge_desc(book_charge_desc),
     _ke_=
      {"tezos_network_desc":js_of_tezos_network_desc(tezos_network_desc),
       "book_charge_desc":_kd_,
       "book_status_desc":_kc_,
       "book_reference":_kb_,
       "provider_info":_ka_,
       "book_entity":_j$_,
       "template_entity":_j__},
     _kf_=aii_endpoint(0),
     apis=
      {"apimode":"sync",
       "_axios":jsaxios,
       "_axios_get":jsaxios,
       "_aii_token":aii_token(0),
       "_aii_endpoint":_kf_,
       "TezosUtilities":api_TezosUtilities,
       "RefMaster":jsapi,
       "InfoBank":jsapi$1,
       "Proto0":jsapi$0,
       "ValueSamples":_ke_};
    export$0(entrypoint,apis);
    global.TSCAInternalInterface = apis;
    debugs(caml_call2(sprintf(_kh_),_kg_,entrypoint));
    do_at_exit(0);
    return}
  (function(){return this}()));



},{"axios":2,"constants":29,"fs":28}],2:[function(require,module,exports){
module.exports = require('./lib/axios');
},{"./lib/axios":4}],3:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = require('./../helpers/cookies');

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

},{"../core/buildFullPath":10,"../core/createError":11,"./../core/settle":15,"./../helpers/buildURL":19,"./../helpers/cookies":21,"./../helpers/isURLSameOrigin":23,"./../helpers/parseHeaders":25,"./../utils":27}],4:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./cancel/Cancel":5,"./cancel/CancelToken":6,"./cancel/isCancel":7,"./core/Axios":8,"./core/mergeConfig":14,"./defaults":17,"./helpers/bind":18,"./helpers/spread":26,"./utils":27}],5:[function(require,module,exports){
'use strict';

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

},{}],6:[function(require,module,exports){
'use strict';

var Cancel = require('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":5}],7:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],8:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

},{"../helpers/buildURL":19,"./../utils":27,"./InterceptorManager":9,"./dispatchRequest":12,"./mergeConfig":14}],9:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":27}],10:[function(require,module,exports){
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');
var combineURLs = require('../helpers/combineURLs');

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

},{"../helpers/combineURLs":20,"../helpers/isAbsoluteURL":22}],11:[function(require,module,exports){
'use strict';

var enhanceError = require('./enhanceError');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":13}],12:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/isCancel":7,"../defaults":17,"./../utils":27,"./transformData":16}],13:[function(require,module,exports){
'use strict';

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};

},{}],14:[function(require,module,exports){
'use strict';

var utils = require('../utils');

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
  var defaultToConfig2Keys = [
    'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',
    'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath'
  ];

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
    if (utils.isObject(config2[prop])) {
      config[prop] = utils.deepMerge(config1[prop], config2[prop]);
    } else if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (utils.isObject(config1[prop])) {
      config[prop] = utils.deepMerge(config1[prop]);
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys);

  var otherKeys = Object
    .keys(config2)
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  return config;
};

},{"../utils":27}],15:[function(require,module,exports){
'use strict';

var createError = require('./createError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

},{"./createError":11}],16:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

},{"./../utils":27}],17:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this,require('_process'))
},{"./adapters/http":3,"./adapters/xhr":3,"./helpers/normalizeHeaderName":24,"./utils":27,"_process":30}],18:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],19:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":27}],20:[function(require,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],21:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);

},{"./../utils":27}],22:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],23:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);

},{"./../utils":27}],24:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":27}],25:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":27}],26:[function(require,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],27:[function(require,module,exports){
'use strict';

var bind = require('./helpers/bind');

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function deepMerge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = deepMerge(result[key], val);
    } else if (typeof val === 'object') {
      result[key] = deepMerge({}, val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  deepMerge: deepMerge,
  extend: extend,
  trim: trim
};

},{"./helpers/bind":18}],28:[function(require,module,exports){

},{}],29:[function(require,module,exports){
module.exports={
  "O_RDONLY": 0,
  "O_WRONLY": 1,
  "O_RDWR": 2,
  "S_IFMT": 61440,
  "S_IFREG": 32768,
  "S_IFDIR": 16384,
  "S_IFCHR": 8192,
  "S_IFBLK": 24576,
  "S_IFIFO": 4096,
  "S_IFLNK": 40960,
  "S_IFSOCK": 49152,
  "O_CREAT": 512,
  "O_EXCL": 2048,
  "O_NOCTTY": 131072,
  "O_TRUNC": 1024,
  "O_APPEND": 8,
  "O_DIRECTORY": 1048576,
  "O_NOFOLLOW": 256,
  "O_SYNC": 128,
  "O_SYMLINK": 2097152,
  "O_NONBLOCK": 4,
  "S_IRWXU": 448,
  "S_IRUSR": 256,
  "S_IWUSR": 128,
  "S_IXUSR": 64,
  "S_IRWXG": 56,
  "S_IRGRP": 32,
  "S_IWGRP": 16,
  "S_IXGRP": 8,
  "S_IRWXO": 7,
  "S_IROTH": 4,
  "S_IWOTH": 2,
  "S_IXOTH": 1,
  "E2BIG": 7,
  "EACCES": 13,
  "EADDRINUSE": 48,
  "EADDRNOTAVAIL": 49,
  "EAFNOSUPPORT": 47,
  "EAGAIN": 35,
  "EALREADY": 37,
  "EBADF": 9,
  "EBADMSG": 94,
  "EBUSY": 16,
  "ECANCELED": 89,
  "ECHILD": 10,
  "ECONNABORTED": 53,
  "ECONNREFUSED": 61,
  "ECONNRESET": 54,
  "EDEADLK": 11,
  "EDESTADDRREQ": 39,
  "EDOM": 33,
  "EDQUOT": 69,
  "EEXIST": 17,
  "EFAULT": 14,
  "EFBIG": 27,
  "EHOSTUNREACH": 65,
  "EIDRM": 90,
  "EILSEQ": 92,
  "EINPROGRESS": 36,
  "EINTR": 4,
  "EINVAL": 22,
  "EIO": 5,
  "EISCONN": 56,
  "EISDIR": 21,
  "ELOOP": 62,
  "EMFILE": 24,
  "EMLINK": 31,
  "EMSGSIZE": 40,
  "EMULTIHOP": 95,
  "ENAMETOOLONG": 63,
  "ENETDOWN": 50,
  "ENETRESET": 52,
  "ENETUNREACH": 51,
  "ENFILE": 23,
  "ENOBUFS": 55,
  "ENODATA": 96,
  "ENODEV": 19,
  "ENOENT": 2,
  "ENOEXEC": 8,
  "ENOLCK": 77,
  "ENOLINK": 97,
  "ENOMEM": 12,
  "ENOMSG": 91,
  "ENOPROTOOPT": 42,
  "ENOSPC": 28,
  "ENOSR": 98,
  "ENOSTR": 99,
  "ENOSYS": 78,
  "ENOTCONN": 57,
  "ENOTDIR": 20,
  "ENOTEMPTY": 66,
  "ENOTSOCK": 38,
  "ENOTSUP": 45,
  "ENOTTY": 25,
  "ENXIO": 6,
  "EOPNOTSUPP": 102,
  "EOVERFLOW": 84,
  "EPERM": 1,
  "EPIPE": 32,
  "EPROTO": 100,
  "EPROTONOSUPPORT": 43,
  "EPROTOTYPE": 41,
  "ERANGE": 34,
  "EROFS": 30,
  "ESPIPE": 29,
  "ESRCH": 3,
  "ESTALE": 70,
  "ETIME": 101,
  "ETIMEDOUT": 60,
  "ETXTBSY": 26,
  "EWOULDBLOCK": 35,
  "EXDEV": 18,
  "SIGHUP": 1,
  "SIGINT": 2,
  "SIGQUIT": 3,
  "SIGILL": 4,
  "SIGTRAP": 5,
  "SIGABRT": 6,
  "SIGIOT": 6,
  "SIGBUS": 10,
  "SIGFPE": 8,
  "SIGKILL": 9,
  "SIGUSR1": 30,
  "SIGSEGV": 11,
  "SIGUSR2": 31,
  "SIGPIPE": 13,
  "SIGALRM": 14,
  "SIGTERM": 15,
  "SIGCHLD": 20,
  "SIGCONT": 19,
  "SIGSTOP": 17,
  "SIGTSTP": 18,
  "SIGTTIN": 21,
  "SIGTTOU": 22,
  "SIGURG": 16,
  "SIGXCPU": 24,
  "SIGXFSZ": 25,
  "SIGVTALRM": 26,
  "SIGPROF": 27,
  "SIGWINCH": 28,
  "SIGIO": 23,
  "SIGSYS": 12,
  "SSL_OP_ALL": 2147486719,
  "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION": 262144,
  "SSL_OP_CIPHER_SERVER_PREFERENCE": 4194304,
  "SSL_OP_CISCO_ANYCONNECT": 32768,
  "SSL_OP_COOKIE_EXCHANGE": 8192,
  "SSL_OP_CRYPTOPRO_TLSEXT_BUG": 2147483648,
  "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS": 2048,
  "SSL_OP_EPHEMERAL_RSA": 0,
  "SSL_OP_LEGACY_SERVER_CONNECT": 4,
  "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER": 32,
  "SSL_OP_MICROSOFT_SESS_ID_BUG": 1,
  "SSL_OP_MSIE_SSLV2_RSA_PADDING": 0,
  "SSL_OP_NETSCAPE_CA_DN_BUG": 536870912,
  "SSL_OP_NETSCAPE_CHALLENGE_BUG": 2,
  "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG": 1073741824,
  "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG": 8,
  "SSL_OP_NO_COMPRESSION": 131072,
  "SSL_OP_NO_QUERY_MTU": 4096,
  "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION": 65536,
  "SSL_OP_NO_SSLv2": 16777216,
  "SSL_OP_NO_SSLv3": 33554432,
  "SSL_OP_NO_TICKET": 16384,
  "SSL_OP_NO_TLSv1": 67108864,
  "SSL_OP_NO_TLSv1_1": 268435456,
  "SSL_OP_NO_TLSv1_2": 134217728,
  "SSL_OP_PKCS1_CHECK_1": 0,
  "SSL_OP_PKCS1_CHECK_2": 0,
  "SSL_OP_SINGLE_DH_USE": 1048576,
  "SSL_OP_SINGLE_ECDH_USE": 524288,
  "SSL_OP_SSLEAY_080_CLIENT_DH_BUG": 128,
  "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG": 0,
  "SSL_OP_TLS_BLOCK_PADDING_BUG": 512,
  "SSL_OP_TLS_D5_BUG": 256,
  "SSL_OP_TLS_ROLLBACK_BUG": 8388608,
  "ENGINE_METHOD_DSA": 2,
  "ENGINE_METHOD_DH": 4,
  "ENGINE_METHOD_RAND": 8,
  "ENGINE_METHOD_ECDH": 16,
  "ENGINE_METHOD_ECDSA": 32,
  "ENGINE_METHOD_CIPHERS": 64,
  "ENGINE_METHOD_DIGESTS": 128,
  "ENGINE_METHOD_STORE": 256,
  "ENGINE_METHOD_PKEY_METHS": 512,
  "ENGINE_METHOD_PKEY_ASN1_METHS": 1024,
  "ENGINE_METHOD_ALL": 65535,
  "ENGINE_METHOD_NONE": 0,
  "DH_CHECK_P_NOT_SAFE_PRIME": 2,
  "DH_CHECK_P_NOT_PRIME": 1,
  "DH_UNABLE_TO_CHECK_GENERATOR": 4,
  "DH_NOT_SUITABLE_GENERATOR": 8,
  "NPN_ENABLED": 1,
  "RSA_PKCS1_PADDING": 1,
  "RSA_SSLV23_PADDING": 2,
  "RSA_NO_PADDING": 3,
  "RSA_PKCS1_OAEP_PADDING": 4,
  "RSA_X931_PADDING": 5,
  "RSA_PKCS1_PSS_PADDING": 6,
  "POINT_CONVERSION_COMPRESSED": 2,
  "POINT_CONVERSION_UNCOMPRESSED": 4,
  "POINT_CONVERSION_HYBRID": 6,
  "F_OK": 0,
  "R_OK": 4,
  "W_OK": 2,
  "X_OK": 1,
  "UV_UDP_REUSEADDR": 4
}

},{}],30:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[1]);
